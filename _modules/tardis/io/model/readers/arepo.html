

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../">
<head>
  <meta charset="utf-8" />
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-53HJHD1BWS"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-53HJHD1BWS');
    </script>
    
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>tardis.io.model.readers.arepo &mdash; tardis</title>
      <link rel="stylesheet" type="text/css" href="../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/plot_directive.css" />

  
    <link rel="shortcut icon" href="../../../../../_static/tardis_logo.ico"/>
      <script src="../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@1.0.13/dist/embed-amd.min.js"></script>
    <script src="../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" />
    <link href="../../../../../_static/tardis.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../index.html" class="icon icon-home">
            tardis
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../quickstart.html">Quickstart for TARDIS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../how_to_guides.html">How-To Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../workflows.html">Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../api/modules.html">API</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Input/Output</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../io/hdf/index.html">Hierarchical Data Format (HDF5)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../io/configuration/index.html">Configuration (Required Input)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../io/model/index.html">Reading Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../io/optional/index.html">Optional Inputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../io/output/index.html">Additional Outputs</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Analyzing Tardis</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../analyzing_tardis/visualization/index.html">Visualization Tools &amp; Widgets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../analyzing_tardis/spectrum/index.html">Analyzing TARDIS Spectra</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../analyzing_tardis/liv_plot_notebook.html">Analyzing Last Interaction Velocity (LIV) Distribution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../analyzing_tardis/rpacket_plot_notebook.html">Analysing Montecarlo Packets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../analyzing_tardis/analysing_convergence_plot.html">Convergence Plots</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Physics Walkthrough</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../physics/intro/index.html">Physics Walkthrough Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../physics/setup/index.html">Setting Up the Simulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../physics/montecarlo/index.html">Monte Carlo Iteration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../physics/update_and_conv/update_and_conv.html">Updating Plasma and Convergence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../physics/spectrum/index.html">Spectrum Generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../physics/tardisgamma/index.html">TARDIS-High Energy</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contributing to TARDIS</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../contributing/CONTRIBUTING.html">Contribution Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../contributing/development/index.html">Developer Workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../contributing/tools/index.html">Developer Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../contributing/CHANGELOG.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../contributing/in_progress/index.html">Features In-Progress</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Other Resources</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../resources/credits.html">Credits &amp; Publication Policies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../resources/research_done_using_TARDIS/research_papers.html">Papers Using TARDIS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../resources/code_comparison/index.html">Code Comparison</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../resources/zreferences.html">References and Glossary</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">tardis</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">tardis.io.model.readers.arepo</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for tardis.io.model.readers.arepo</h1><div class="highlight"><pre>
<span></span>import argparse
import os

import matplotlib.pyplot as plt
import numpy as np
from scipy import stats


<div class="viewcode-block" id="ArepoSnapshot">
<a class="viewcode-back" href="../../../../../api/tardis.io.model.readers.arepo.html#tardis.io.model.readers.arepo.ArepoSnapshot">[docs]</a>
class ArepoSnapshot:
    def __init__(
        self,
        filename,
        species,
        speciesfile,
        alpha=0.0,
        beta=0.0,
        gamma=0.0,
    ):
        &quot;&quot;&quot;
        Loads relevant data for conversion from Arepo snapshot to a
        csvy-model. Requires arepo-snap-util to be installed.
        The snapshot is mapped onto a Cartesian grid before further
        processing is done.

        Parameters
        ----------
        filename : str
            Path to file to be converted.
        species : list of str
            Names of the species to be exported. Have to be the
            same as in the species-file of the Arepo simulation
        speciesfile : str
            File specifying the species used in the Arepo
            simulation.
        alpha : float
            Euler angle alpha for rotation of the desired line-
            of-sight to the x-axis. Only usable with snapshots.
            Default: 0.0
        beta : float
            Euler angle beta for rotation of the desired line-
            of-sight to the x-axis. Only usable with snapshots.
            Default: 0.0
        gamma : float
            Euler angle gamma for rotation of the desired line-
            of-sight to the x-axis. Only usable with snapshots.
            Default: 0.0
        &quot;&quot;&quot;
        try:
            import gadget_snap
        except ModuleNotFoundError:
            raise ImportError(
                &quot;Please make sure you have arepo-snap-util installed if you want to directly import Arepo snapshots.&quot;
            )

        self.species = species
        species_full = np.genfromtxt(speciesfile, skip_header=1, dtype=str).T[0]
        self.spec_ind = []
        for spec in self.species:
            self.spec_ind.append(np.where(species_full == spec)[0][0])

        self.spec_ind = np.array(self.spec_ind)

        self.s = gadget_snap.gadget_snapshot(
            filename,
            hdf5=True,
            quiet=True,
            lazy_load=True,
            loadonlytype=[0],
        )

        rz_yaw = np.array(
            [
                [np.cos(alpha), -np.sin(alpha), 0],
                [np.sin(alpha), np.cos(alpha), 0],
                [0, 0, 1],
            ]
        )
        ry_pitch = np.array(
            [
                [np.cos(beta), 0, np.sin(beta)],
                [0, 1, 0],
                [-np.sin(beta), 0, np.cos(beta)],
            ]
        )
        rx_roll = np.array(
            [
                [1, 0, 0],
                [0, np.cos(gamma), -np.sin(gamma)],
                [0, np.sin(gamma), np.cos(gamma)],
            ]
        )
        # R = RzRyRx
        rotmat = np.dot(rz_yaw, np.dot(ry_pitch, rx_roll))

        self.s.rotateto(rotmat[0], dir2=rotmat[1], dir3=rotmat[2])

        self.time = self.s.time
        self.pos = np.array(self.s.data[&quot;pos&quot;])
        self.pos = self.pos.T
        # Update position to CoM frame
        for i in range(3):
            self.pos[i] -= self.s.centerofmass()[i]
        self.rho = np.array(self.s.data[&quot;rho&quot;])
        self.mass = np.array(self.s.data[&quot;mass&quot;])
        self.vel = np.array(self.s.data[&quot;vel&quot;])
        self.vel = self.vel.T
        self.nuc_dict = {}

        for i, spec in enumerate(self.species):
            self.nuc_dict[spec] = np.array(
                self.s.data[&quot;xnuc&quot;][:, self.spec_ind[i]]
            )

<div class="viewcode-block" id="ArepoSnapshot.get_grids">
<a class="viewcode-back" href="../../../../../api/tardis.io.model.readers.arepo.html#tardis.io.model.readers.arepo.ArepoSnapshot.get_grids">[docs]</a>
    def get_grids(self):
        &quot;&quot;&quot;
        Returns all relevant data to create Profile objects
        &quot;&quot;&quot;
        return self.pos, self.vel, self.rho, self.mass, self.nuc_dict, self.time</div>
</div>



<div class="viewcode-block" id="Profile">
<a class="viewcode-back" href="../../../../../api/tardis.io.model.readers.arepo.html#tardis.io.model.readers.arepo.Profile">[docs]</a>
class Profile:
    &quot;&quot;&quot;
    Parent class of all Profiles. Contains general function,
    e.g. for plotting and export.
    &quot;&quot;&quot;

    def __init__(self, pos, vel, rho, mass, xnuc, time):
        &quot;&quot;&quot;
        Parameters
        ----------
        pos : list of float
            Meshgrid of positions in center of mass frames in
            Cartesian coordinates
        vel : list of float
            Meshgrid of velocities/ velocity vectors
        rho : list of float
            Meshgrid of density
        mass : list of float
            Meshgrid of masses.
        xnuc : dict
            Dictonary containing all the nuclear fraction
            meshgrids of the relevant species.
        time : float
            Time of the data

        &quot;&quot;&quot;
        self.pos = pos
        self.vel = vel
        self.rho = rho
        self.xnuc = xnuc
        self.time = time
        self.mass = mass
        self.vol = self.mass / self.rho
        self.species = list(self.xnuc.keys())

        # Empty values to be filled with the create_profile function
        self.pos_prof_p = None
        self.pos_prof_n = None

        self.vel_prof_p = None
        self.vel_prof_n = None

        self.vol_prof_p = None
        self.vol_prof_n = None

        self.mass_prof_p = None
        self.mass_prof_n = None

        self.rho_prof_p = None
        self.rho_prof_n = None

        self.xnuc_prof_p = {}
        self.xnuc_prof_n = {}

<div class="viewcode-block" id="Profile.plot_profile">
<a class="viewcode-back" href="../../../../../api/tardis.io.model.readers.arepo.html#tardis.io.model.readers.arepo.Profile.plot_profile">[docs]</a>
    def plot_profile(self, save=None, dpi=600, **kwargs):
        &quot;&quot;&quot;
        Plots profile, both in the positive and negative direction.

        Parameters
        ----------
        save : str
            Path under which the figure is to be saved. Default: None
        dpi : int
            Dpi of the saved figure
        **kwargs : keywords passable to matplotlib.pyplot.plot()

        Returns
        -------
        fig : matplotlib figure object
        &quot;&quot;&quot;
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=[9.8, 9.6])

        # Positive direction plots
        ax1.plot(
            self.pos_prof_p,
            self.rho_prof_p / max(self.rho_prof_p),
            label=&quot;Density&quot;,
            **kwargs,
        )
        ax1.plot(
            self.pos_prof_p,
            self.vel_prof_p / max(self.vel_prof_p),
            label=&quot;Velocity&quot;,
            **kwargs,
        )
        for spec in self.species:
            ax1.plot(
                self.pos_prof_p,
                self.xnuc_prof_p[spec],
                label=spec.capitalize(),
                **kwargs,
            )

        ax1.grid()
        ax1.set_ylabel(&quot;Profile (arb. unit)&quot;)
        ax1.set_title(&quot;Profiles along the positive axis&quot;)

        # Negative direction plots
        ax2.plot(
            self.pos_prof_n,
            self.rho_prof_n / max(self.rho_prof_n),
            label=&quot;Density&quot;,
            **kwargs,
        )
        ax2.plot(
            self.pos_prof_n,
            self.vel_prof_n / max(self.vel_prof_n),
            label=&quot;Velocity&quot;,
            **kwargs,
        )
        for spec in self.species:
            ax2.plot(
                self.pos_prof_n,
                self.xnuc_prof_n[spec],
                label=spec.capitalize(),
                **kwargs,
            )

        ax2.grid()
        ax2.set_ylabel(&quot;Profile (arb. unit)&quot;)
        ax2.set_xlabel(&quot;Radial position (cm)&quot;)
        ax2.set_title(&quot;Profiles along the negative axis&quot;)

        # Some styling
        fig.tight_layout()

        handles, labels = ax1.get_legend_handles_labels()
        lgd = ax1.legend(
            handles,
            labels,
            loc=&quot;upper left&quot;,
            bbox_to_anchor=(1.05, 1.05),
            title=f&quot;Time = {self.time:.2f} s&quot;,
        )
        if save is not None:
            plt.savefig(
                save,
                bbox_inches=&quot;tight&quot;,
                dpi=dpi,
            )

        return fig</div>


<div class="viewcode-block" id="Profile.rebin">
<a class="viewcode-back" href="../../../../../api/tardis.io.model.readers.arepo.html#tardis.io.model.readers.arepo.Profile.rebin">[docs]</a>
    def rebin(self, nshells):
        &quot;&quot;&quot;
        Rebins the data to nshells. Uses the scipy.stats.binned_statistic
        to bin the data. The standard deviation of each bin can be obtained
        by passing the statistics=&quot;std&quot; keyword.

        Parameters
        ----------
        nshells : int
            Number of bins of new data.

        Returns
        -------
        self : Profile object

        &quot;&quot;&quot;
        self.vel_prof_p, bins_p = stats.binned_statistic(
            self.pos_prof_p,
            self.vel_prof_p * self.mass_prof_p,
            statistic=&quot;mean&quot;,
            bins=nshells,
        )[:2]
        self.vel_prof_p /= stats.binned_statistic(
            self.pos_prof_p,
            self.mass_prof_p,
            statistic=&quot;mean&quot;,
            bins=nshells,
        )[0]
        self.vel_prof_n, bins_n = stats.binned_statistic(
            self.pos_prof_n,
            self.vel_prof_n * self.mass_prof_n,
            statistic=&quot;mean&quot;,
            bins=nshells,
        )[:2]
        self.vel_prof_n /= stats.binned_statistic(
            self.pos_prof_n,
            self.mass_prof_n,
            statistic=&quot;mean&quot;,
            bins=nshells,
        )[0]

        for spec in self.species:
            self.xnuc_prof_p[spec] = (
                stats.binned_statistic(
                    self.pos_prof_p,
                    self.xnuc_prof_p[spec] * self.mass_prof_p,
                    statistic=&quot;mean&quot;,
                    bins=nshells,
                )[0]
                / stats.binned_statistic(
                    self.pos_prof_p,
                    self.mass_prof_p,
                    statistic=&quot;mean&quot;,
                    bins=nshells,
                )[0]
            )
            self.xnuc_prof_n[spec] = (
                stats.binned_statistic(
                    self.pos_prof_n,
                    self.xnuc_prof_n[spec] * self.mass_prof_n,
                    statistic=&quot;mean&quot;,
                    bins=nshells,
                )[0]
                / stats.binned_statistic(
                    self.pos_prof_n,
                    self.mass_prof_n,
                    statistic=&quot;mean&quot;,
                    bins=nshells,
                )[0]
            )

        self.vol_prof_p = np.array(
            [
                4 / 3 * np.pi * (bins_p[i + 1] ** 3 - bins_p[i] ** 3)
                for i in range(len(bins_p) - 1)
            ]
        )
        self.vol_prof_n = np.array(
            [
                4 / 3 * np.pi * (bins_n[i + 1] ** 3 - bins_n[i] ** 3)
                for i in range(len(bins_n) - 1)
            ]
        )

        self.mass_prof_p = stats.binned_statistic(
            self.pos_prof_p,
            self.mass_prof_p,
            statistic=&quot;sum&quot;,
            bins=nshells,
        )[0]
        self.mass_prof_n = stats.binned_statistic(
            self.pos_prof_n,
            self.mass_prof_n,
            statistic=&quot;sum&quot;,
            bins=nshells,
        )[0]

        self.rho_prof_p = self.mass_prof_p / self.vol_prof_p
        self.rho_prof_n = self.mass_prof_n / self.vol_prof_n

        self.pos_prof_p = np.array(
            [(bins_p[i] + bins_p[i + 1]) / 2 for i in range(len(bins_p) - 1)]
        )
        self.pos_prof_n = np.array(
            [(bins_n[i] + bins_n[i + 1]) / 2 for i in range(len(bins_n) - 1)]
        )

        return self</div>


<div class="viewcode-block" id="Profile.export">
<a class="viewcode-back" href="../../../../../api/tardis.io.model.readers.arepo.html#tardis.io.model.readers.arepo.Profile.export">[docs]</a>
    def export(
        self,
        nshells,
        filename,
        direction=&quot;pos&quot;,
        overwrite=False,
    ):
        &quot;&quot;&quot;
        Function to export a profile as csvy file. Either the
        positive or negative direction can be exported. By default
        does not overwrite existing files, saves to &lt;filename&gt;_&lt;number&gt;.csvy
        file instead.

        Parameters
        ----------
        nshells : int
            Number of shells to be exported.
        filename : str
            Name of the exported file
        direction : str
            Specifies if either the positive or negative
            direction is to be exported. Available
            options: [&#39;pos&#39;, &#39;neg&#39;]. Default: pos
        overwrite: bool
            If true, will overwrite if a file of the same name exists.
            By default False.

        Returns
        -------
        filename : str
            Name of the actual saved file
        &quot;&quot;&quot;
        # Find a free filename
        if str(filename).endswith(&quot;.csvy&quot;):
            filename = str(filename).replace(&quot;.csvy&quot;, &quot;&quot;)

        if os.path.exists(f&quot;{filename}.csvy&quot;) and not overwrite:
            i = 0
            while os.path.exists(f&quot;{filename}_{i}.csvy&quot;):
                i += 1
            filename = f&quot;{filename}_{i}.csvy&quot;
        else:
            filename = f&quot;{filename}.csvy&quot;

        with open(filename, &quot;w&quot;) as f:
            # WRITE HEADER
            f.write(
                &quot;&quot;.join(
                    [
                        &quot;---\n&quot;,
                        &quot;name: csvy_full\n&quot;,
                        f&quot;model_density_time_0: {self.time / (3600 * 24):g} day\n&quot;,  # TODO astropy units
                        f&quot;model_isotope_time_0: {self.time / (3600 / 24):g} day\n&quot;,  # TODO astropy units
                        &quot;description: Config file for TARDIS from Arepo snapshot.\n&quot;,
                        &quot;tardis_model_config_version: v1.0\n&quot;,
                        &quot;datatype:\n&quot;,
                        &quot;  fields:\n&quot;,
                        &quot;    -  name: velocity\n&quot;,
                        &quot;       unit: cm/s\n&quot;,
                        &quot;       desc: velocities of shell outer bounderies.\n&quot;,
                        &quot;    -  name: density\n&quot;,
                        &quot;       unit: g/cm^3\n&quot;,
                        &quot;       desc: density of shell.\n&quot;,
                    ]
                )
            )

            for spec in self.species:
                f.write(
                    &quot;&quot;.join(
                        [
                            f&quot;    -  name: {spec.capitalize()}\n&quot;,
                            f&quot;       desc: fractional {spec.capitalize()} abundance.\n&quot;,
                        ]
                    )
                )

            f.write(&quot;\n---\n&quot;)

            # WRITE DATA
            datastring = [&quot;velocity,&quot;, &quot;density,&quot;]
            for spec in self.species[:-1]:
                datastring.append(f&quot;{spec.capitalize()},&quot;)
            datastring.append(f&quot;{self.species[-1].capitalize()}&quot;)
            f.write(&quot;&quot;.join(datastring))

            # Rebin data to nshells
            self.rebin(nshells)

            if direction == &quot;pos&quot;:
                exp = [
                    self.vel_prof_p,
                    self.rho_prof_p,
                ]
                for spec in self.xnuc_prof_p:
                    exp.append(self.xnuc_prof_p[spec])
            elif direction == &quot;neg&quot;:
                exp = [
                    self.vel_prof_n,
                    self.rho_prof_n,
                ]
                for spec in self.xnuc_prof_n:
                    exp.append(self.xnuc_prof_n[spec])
            else:
                raise ValueError(&quot;Unrecognized option for keyword &#39;direction&#39;&quot;)

            inds = np.linspace(0, len(exp[0]) - 1, num=nshells, dtype=int)

            for i in inds:
                f.write(&quot;\n&quot;)
                for ii in range(len(exp) - 1):
                    f.write(f&quot;{exp[ii][i]:g},&quot;)
                f.write(f&quot;{exp[-1][i]:g}&quot;)

        return filename</div>


<div class="viewcode-block" id="Profile.get_profiles">
<a class="viewcode-back" href="../../../../../api/tardis.io.model.readers.arepo.html#tardis.io.model.readers.arepo.Profile.get_profiles">[docs]</a>
    def get_profiles(self):
        &quot;&quot;&quot;Returns all profiles for manual post_processing etc.&quot;&quot;&quot;
        return (
            self.pos_prof_p,
            self.pos_prof_n,
            self.vel_prof_p,
            self.vel_prof_n,
            self.rho_prof_p,
            self.rho_prof_n,
            self.mass_prof_p,
            self.mass_prof_n,
            self.xnuc_prof_p,
            self.xnuc_prof_n,
        )</div>
</div>



<div class="viewcode-block" id="ConeProfile">
<a class="viewcode-back" href="../../../../../api/tardis.io.model.readers.arepo.html#tardis.io.model.readers.arepo.ConeProfile">[docs]</a>
class ConeProfile(Profile):
    &quot;&quot;&quot;
    Class for profiles extracted inside a cone around the x-axis.
    Extends Profile.
    &quot;&quot;&quot;

<div class="viewcode-block" id="ConeProfile.create_profile">
<a class="viewcode-back" href="../../../../../api/tardis.io.model.readers.arepo.html#tardis.io.model.readers.arepo.ConeProfile.create_profile">[docs]</a>
    def create_profile(
        self,
        opening_angle=20.0,
        inner_radius=None,
        outer_radius=None,
        show_plot=True,
        save_plot=None,
        plot_dpi=600,
    ):
        &quot;&quot;&quot;
        Creates a profile along the x-axis without any averaging

        Parameters
        ----------
        opening_angle : float
            Opening angle (in degrees) of the cone from which the
            data is extracted. Refers to the total opening angle, not
            the angle with respect to the x axis. Default: 20.0
        inner_radius : float
            Inner radius where the profiles will be cut off. Default: None
        outer_radius : float
            Outer radius where the profiles will be cut off. Default: None

        Returns
        -------
        profile : ConeProfile object

        &quot;&quot;&quot;
        # Convert Cartesian coordinates into cylindrical coordinates
        # P(x,y,z) -&gt; P(x,r,theta)
        cyl = np.array(
            [
                self.pos[0],
                np.sqrt(self.pos[1] ** 2 + self.pos[2] ** 2),
                np.arctan(self.pos[2] / self.pos[1]),
            ]
        )

        # Get maximum allowed r of points to still be in cone
        dist = np.tan(opening_angle / 2) * np.abs(cyl[0])

        # Create masks
        cmask_p = np.logical_and(cyl[0] &gt; 0, cyl[1] &lt;= dist)
        cmask_n = np.logical_and(cyl[0] &lt; 0, cyl[1] &lt;= dist)

        # Apply mask to data
        pos_p = np.sqrt(
            (self.pos[0][cmask_p]) ** 2
            + (self.pos[1][cmask_p]) ** 2
            + (self.pos[2][cmask_p]) ** 2
        )
        pos_n = np.sqrt(
            self.pos[0][cmask_n] ** 2
            + self.pos[1][cmask_n] ** 2
            + self.pos[2][cmask_n] ** 2
        )

        vel_p = np.sqrt(
            self.vel[0][cmask_p] ** 2
            + self.vel[1][cmask_p] ** 2
            + self.vel[2][cmask_p] ** 2
        )
        vel_n = np.sqrt(
            self.vel[0][cmask_n] ** 2
            + self.vel[1][cmask_n] ** 2
            + self.vel[2][cmask_n] ** 2
        )

        vol_p = self.vol[cmask_p]
        vol_n = self.vol[cmask_n]

        mass_p = self.mass[cmask_p]
        mass_n = self.mass[cmask_n]

        rho_p = self.rho[cmask_p]
        rho_n = self.rho[cmask_n]

        spec_p = {}
        spec_n = {}

        for spec in self.species:
            spec_p[spec] = self.xnuc[spec][cmask_p]
            spec_n[spec] = self.xnuc[spec][cmask_n]

        self.pos_prof_p = np.sort(pos_p)
        self.pos_prof_n = np.sort(pos_n)

        if outer_radius is None:
            maxradius_p = max(self.pos_prof_p)
            maxradius_n = max(self.pos_prof_n)
        else:
            maxradius_p = outer_radius
            maxradius_n = outer_radius

        if inner_radius is None:
            minradius_p = min(self.pos_prof_p)
            minradius_n = min(self.pos_prof_n)
        else:
            minradius_p = inner_radius
            minradius_n = inner_radius

        mask_p = np.logical_and(
            self.pos_prof_p &gt;= minradius_p, self.pos_prof_p &lt;= maxradius_p
        )
        mask_n = np.logical_and(
            self.pos_prof_n &gt;= minradius_n, self.pos_prof_n &lt;= maxradius_n
        )

        if not mask_p.any() or not mask_n.any():
            raise ValueError(&quot;No points left between inner and outer radius.&quot;)

        self.vol_prof_p = np.array(
            [x for _, x in sorted(zip(pos_p, vol_p), key=lambda pair: pair[0])]
        )[mask_p]
        self.vol_prof_n = np.array(
            [x for _, x in sorted(zip(pos_n, vol_n), key=lambda pair: pair[0])]
        )[mask_n]

        self.mass_prof_p = np.array(
            [x for _, x in sorted(zip(pos_p, mass_p), key=lambda pair: pair[0])]
        )[mask_p]
        self.mass_prof_n = np.array(
            [x for _, x in sorted(zip(pos_n, mass_n), key=lambda pair: pair[0])]
        )[mask_n]

        self.rho_prof_p = np.array(
            [x for _, x in sorted(zip(pos_p, rho_p), key=lambda pair: pair[0])]
        )[mask_p]
        self.rho_prof_n = np.array(
            [x for _, x in sorted(zip(pos_n, rho_n), key=lambda pair: pair[0])]
        )[mask_n]

        self.vel_prof_p = np.array(
            [x for _, x in sorted(zip(pos_p, vel_p), key=lambda pair: pair[0])]
        )[mask_p]
        self.vel_prof_n = np.array(
            [x for _, x in sorted(zip(pos_n, vel_n), key=lambda pair: pair[0])]
        )[mask_n]

        for spec in self.species:
            self.xnuc_prof_p[spec] = np.array(
                [
                    x
                    for _, x in sorted(
                        zip(pos_p, spec_p[spec]), key=lambda pair: pair[0]
                    )
                ]
            )[mask_p]
            self.xnuc_prof_n[spec] = np.array(
                [
                    x
                    for _, x in sorted(
                        zip(pos_n, spec_n[spec]), key=lambda pair: pair[0]
                    )
                ]
            )[mask_n]

        self.pos_prof_p = self.pos_prof_p[mask_p]
        self.pos_prof_n = self.pos_prof_n[mask_n]

        return self</div>
</div>



<div class="viewcode-block" id="FullProfile">
<a class="viewcode-back" href="../../../../../api/tardis.io.model.readers.arepo.html#tardis.io.model.readers.arepo.FullProfile">[docs]</a>
class FullProfile(Profile):
    &quot;&quot;&quot;
    Class for profiles extracted from the full snapshot,
    i.e. angle averaged profiles.
    Extends Profile.
    &quot;&quot;&quot;

<div class="viewcode-block" id="FullProfile.create_profile">
<a class="viewcode-back" href="../../../../../api/tardis.io.model.readers.arepo.html#tardis.io.model.readers.arepo.FullProfile.create_profile">[docs]</a>
    def create_profile(
        self,
        inner_radius=None,
        outer_radius=None,
        show_plot=True,
        save_plot=None,
        plot_dpi=600,
    ):
        &quot;&quot;&quot;
        Creates a profile from the full snapshot. Positive and negative
        direction are identical.

        Parameters
        ----------
        inner_radius : float
            Inner radius where the profiles will be cut off. Default: None
        outer_radius : float
            Outer radius where the profiles will be cut off. Default: None

        Returns
        -------
        profile : FullProfile object

        &quot;&quot;&quot;
        pos_p = np.sqrt(
            (self.pos[0]) ** 2 + (self.pos[1]) ** 2 + (self.pos[2]) ** 2
        ).flatten()
        pos_n = np.sqrt(
            self.pos[0] ** 2 + self.pos[1] ** 2 + self.pos[2] ** 2
        ).flatten()

        vel_p = np.sqrt(
            self.vel[0] ** 2 + self.vel[1] ** 2 + self.vel[2] ** 2
        ).flatten()
        vel_n = np.sqrt(
            self.vel[0] ** 2 + self.vel[1] ** 2 + self.vel[2] ** 2
        ).flatten()

        vol_p = self.vol.flatten()
        vol_n = self.vol.flatten()

        mass_p = self.mass.flatten()
        mass_n = self.mass.flatten()

        rho_p = self.rho.flatten()
        rho_n = self.rho.flatten()

        spec_p = {}
        spec_n = {}

        for spec in self.species:
            spec_p[spec] = self.xnuc[spec].flatten()
            spec_n[spec] = self.xnuc[spec].flatten()

        self.pos_prof_p = np.sort(pos_p)
        self.pos_prof_n = np.sort(pos_n)

        if outer_radius is None:
            maxradius_p = max(self.pos_prof_p)
            maxradius_n = max(self.pos_prof_n)
        else:
            maxradius_p = outer_radius
            maxradius_n = outer_radius

        if inner_radius is None:
            minradius_p = min(self.pos_prof_p)
            minradius_n = min(self.pos_prof_n)
        else:
            minradius_p = inner_radius
            minradius_n = inner_radius

        mask_p = np.logical_and(
            self.pos_prof_p &gt;= minradius_p, self.pos_prof_p &lt;= maxradius_p
        )
        mask_n = np.logical_and(
            self.pos_prof_n &gt;= minradius_n, self.pos_prof_n &lt;= maxradius_n
        )

        if not mask_p.any() or not mask_n.any():
            raise ValueError(&quot;No points left between inner and outer radius.&quot;)

        self.vol_prof_p = np.array(
            [x for _, x in sorted(zip(pos_p, vol_p), key=lambda pair: pair[0])]
        )[mask_p]
        self.vol_prof_n = np.array(
            [x for _, x in sorted(zip(pos_n, vol_n), key=lambda pair: pair[0])]
        )[mask_n]

        self.mass_prof_p = np.array(
            [x for _, x in sorted(zip(pos_p, mass_p), key=lambda pair: pair[0])]
        )[mask_p]
        self.mass_prof_n = np.array(
            [x for _, x in sorted(zip(pos_n, mass_n), key=lambda pair: pair[0])]
        )[mask_n]

        self.rho_prof_p = np.array(
            [x for _, x in sorted(zip(pos_p, rho_p), key=lambda pair: pair[0])]
        )[mask_p]
        self.rho_prof_n = np.array(
            [x for _, x in sorted(zip(pos_n, rho_n), key=lambda pair: pair[0])]
        )[mask_n]

        self.vel_prof_p = np.array(
            [x for _, x in sorted(zip(pos_p, vel_p), key=lambda pair: pair[0])]
        )[mask_p]
        self.vel_prof_n = np.array(
            [x for _, x in sorted(zip(pos_n, vel_n), key=lambda pair: pair[0])]
        )[mask_n]

        for spec in self.species:
            self.xnuc_prof_p[spec] = np.array(
                [
                    x
                    for _, x in sorted(
                        zip(pos_p, spec_p[spec]), key=lambda pair: pair[0]
                    )
                ]
            )[mask_p]
            self.xnuc_prof_n[spec] = np.array(
                [
                    x
                    for _, x in sorted(
                        zip(pos_n, spec_n[spec]), key=lambda pair: pair[0]
                    )
                ]
            )[mask_n]

        self.pos_prof_p = self.pos_prof_p[mask_p]
        self.pos_prof_n = self.pos_prof_n[mask_n]

        return self</div>
</div>



if __name__ == &quot;__main__&quot;:
    parser = argparse.ArgumentParser()

    parser.add_argument(
        &quot;snapshot&quot;,
        help=&quot;Snapshot file for which to create velocity profile plot&quot;,
    )
    parser.add_argument(
        &quot;save&quot;,
        help=&quot;Filename of exported .csvy file&quot;,
    )
    parser.add_argument(
        &quot;-a&quot;,
        &quot;--alpha&quot;,
        help=&quot;Euler angle alpha for rotation of desired direction to x-axis. Default: 0&quot;,
        type=float,
        default=0.0,
    )
    parser.add_argument(
        &quot;-b&quot;,
        &quot;--beta&quot;,
        help=&quot;Euler angle beta for rotation of desired direction to x-axis. Default: 0&quot;,
        type=float,
        default=0.0,
    )
    parser.add_argument(
        &quot;-g&quot;,
        &quot;--gamma&quot;,
        help=&quot;Euler angle gamma for rotation of desired direction to x-axis. Default: 0&quot;,
        type=float,
        default=0.0,
    )
    parser.add_argument(
        &quot;-o&quot;,
        &quot;--opening_angle&quot;,
        help=&quot;Opening angle of the cone from which profile is extracted. Default 20.0&quot;,
        type=float,
        default=20.0,
    )
    parser.add_argument(
        &quot;-n&quot;,
        &quot;--nshells&quot;,
        help=&quot;Number of shells to create. Default: 10&quot;,
        type=int,
        default=10,
    )
    parser.add_argument(
        &quot;-x&quot;,
        &quot;--boxsize&quot;,
        help=&quot;Size of the box (in cm) from which data is extracted. Default: 1e12&quot;,
        type=float,
        default=1e12,
    )
    parser.add_argument(
        &quot;-e&quot;,
        &quot;--elements&quot;,
        help=&quot;List of species to be included. Default: ni56&quot;,
        default=&quot;ni56&quot;,
        nargs=&quot;+&quot;,
    )
    parser.add_argument(
        &quot;--eosspecies&quot;,
        help=&quot;Species file including all the species used in the production of the composition file. Default: species55.txt&quot;,
        default=&quot;species55.txt&quot;,
    )
    parser.add_argument(
        &quot;--outer_radius&quot;,
        help=&quot;Outer radius to which to build profile.&quot;,
        type=float,
    )
    parser.add_argument(
        &quot;--inner_radius&quot;,
        help=&quot;Inner radius to which to build profile.&quot;,
        type=float,
    )
    parser.add_argument(
        &quot;--profile&quot;,
        help=&quot;How to build profile. Available options: [cone, full]. Default: cone&quot;,
        default=&quot;cone&quot;,
        choices=[&quot;cone&quot;, &quot;full&quot;],
    )
    parser.add_argument(&quot;--plot&quot;, help=&quot;File name of saved plot.&quot;)
    parser.add_argument(
        &quot;--dpi&quot;, help=&quot;Dpi of saved plot. Default: 600&quot;, type=int, default=600
    )

    args = parser.parse_args()

    snapshot = ArepoSnapshot(
        args.snapshot,
        args.elements,
        args.eosspecies,
        alpha=args.alpha,
        beta=args.beta,
        gamma=args.gamma,
        boxsize=args.boxsize,
        resolution=args.resolution,
        numthreads=args.numthreads,
    )

    pos, vel, rho, mass, xnuc, time = snapshot.get_grids()

    if args.profile == &quot;cone&quot;:
        profile = ConeProfile(pos, vel, rho, xnuc, time, mass=mass)
    elif args.profile == &quot;full&quot;:
        profile = FullProfile(pos, vel, rho, xnuc, time, mass=mass)

    if args.profile == &quot;cone&quot;:
        profile.create_profile(
            opening_angle=args.opening_angle,
            inner_radius=args.inner_radius,
            outer_radius=args.outer_radius,
        )
    else:
        profile.create_profile(
            inner_radius=args.inner_radius,
            outer_radius=args.outer_radius,
        )

    profile.export(args.nshells, args.save)

    if args.plot:
        profile.plot_profile(save=args.plot, dpi=args.dpi)
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2013-2025, TARDIS Collaboration.
      <span class="lastupdated">Last updated on 19 May 2025.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>