

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../">
<head>
  <meta charset="utf-8" />
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-53HJHD1BWS"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-53HJHD1BWS');
    </script>
    
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>tardis.plasma.properties.continuum_processes.rates &mdash; tardis</title>
      <link rel="stylesheet" type="text/css" href="../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../../../../_static/plot_directive.css" />

  
    <link rel="shortcut icon" href="../../../../../_static/tardis_logo.ico"/>
      <script src="../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../_static/documentation_options.js?v=e462899a"></script>
      <script src="../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@1.0.13/dist/embed-amd.min.js"></script>
    <script src="../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" />
    <link href="../../../../../_static/tardis.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../index.html" class="icon icon-home">
            tardis
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../getting_started/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../quickstart.html">Quickstart for TARDIS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../resources/credits.html">Credits &amp; Publication Policies</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../tutorials/high_energy/run_high_energy_workflow.html">TARDIS High Energy Workflow Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../analyzing_tardis/visualization/tutorial_montecarlo_packet_visualization.html">Montecarlo Packet Visualization</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">How-to Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../how_to_guides.html">How-To Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../workflows.html">Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../analyzing_tardis/index.html">Analyszing TARDIS Simulation Outputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../io/configuration/tutorial_read_configuration.html">Reading a Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../io/optional/index.html">Optional Inputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../io/output/index.html">Additional Outputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../how-to/code_comparison/index.html">How to do Code Comparison using TARDIS</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Physics Walkthrough</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../physics_walkthrough/intro/index.html">Physics Walkthrough Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../physics_walkthrough/setup/index.html">Setting Up the Simulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../physics_walkthrough/montecarlo/index.html">Monte Carlo Iteration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../physics_walkthrough/update_and_conv/update_and_conv.html">Updating Plasma and Convergence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../physics_walkthrough/spectrum/index.html">Spectrum Generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../physics_walkthrough/tardisgamma/index.html">TARDIS-High Energy</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../api/modules.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../reference/faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../reference/visualization_reference.html">Visualization Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../io/configuration/index.html">Configuration Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../io/hdf/index.html">Hierarchical Data Format (HDF5) Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../contributing/CHANGELOG.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../resources/research_done_using_TARDIS/research_papers.html">Papers Using TARDIS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../resources/zreferences.html">Bibliography and Glossary</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contributing to TARDIS</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../contributing/CONTRIBUTING.html">Contribution Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../contributing/development/index.html">Developer Workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../contributing/tools/index.html">Developer Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../contributing/in_progress/index.html">Features In-Progress</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">tardis</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">tardis.plasma.properties.continuum_processes.rates</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for tardis.plasma.properties.continuum_processes.rates</h1><div class="highlight"><pre>
<span></span>import logging

import numpy as np
import pandas as pd
from numba import njit

from tardis import constants as const
from tardis.plasma.exceptions import PlasmaException
from tardis.plasma.properties.base import (
    Input,
    ProcessingPlasmaProperty,
    TransitionProbabilitiesProperty,
)
from tardis.plasma.properties.continuum_processes.fast_array_util import (
    cumulative_integrate_array_by_blocks,
    numba_cumulative_trapezoid,
)
from tardis.transport.montecarlo.estimators.util import (
    integrate_array_by_blocks,
)
from tardis.configuration.sorting_globals import SORTING_ALGORITHM

__all__ = [
    &quot;CorrPhotoIonRateCoeff&quot;,
    &quot;BfHeatingRateCoeffEstimator&quot;,
    &quot;StimRecombCoolingRateCoeffEstimator&quot;,
    &quot;SpontRecombCoolingRateCoeff&quot;,
    &quot;RawRecombTransProbs&quot;,
    &quot;RawPhotoIonTransProbs&quot;,
    &quot;CollDeexcRateCoeff&quot;,
    &quot;CollExcRateCoeff&quot;,
    &quot;CollRecombRateCoeff&quot;,
    &quot;RawCollisionTransProbs&quot;,
    &quot;AdiabaticCoolingRate&quot;,
    &quot;FreeFreeCoolingRate&quot;,
    &quot;FreeBoundCoolingRate&quot;,
    &quot;LevelNumberDensityLTE&quot;,
    &quot;PhotoIonBoltzmannFactor&quot;,
    &quot;FreeBoundEmissionCDF&quot;,
    &quot;RawTwoPhotonTransProbs&quot;,
    &quot;TwoPhotonEmissionCDF&quot;,
    &quot;TwoPhotonFrequencySampler&quot;,
    &quot;CollIonRateCoeffSeaton&quot;,
]

N_A = const.N_A.cgs.value
K_B = const.k_B.cgs.value
C = const.c.cgs.value
H = const.h.cgs.value
A0 = const.a0.cgs.value
M_E = const.m_e.cgs.value
E = const.e.esu.value
BETA_COLL = (H**4 / (8 * K_B * M_E**3 * np.pi**3)) ** 0.5
F_K = (
    16
    / (3.0 * np.sqrt(3))
    * np.sqrt((2 * np.pi) ** 3 * K_B / (H**2 * M_E**3))
    * (E**2 / C) ** 3
)  # See Eq. 19 in Sutherland, R. S. 1998, MNRAS, 300, 321
FF_OPAC_CONST = (
    (2 * np.pi / (3 * M_E * K_B)) ** 0.5 * 4 * E**6 / (3 * M_E * H * C)
)  # See Eq. 6.1.8 in http://personal.psu.edu/rbc3/A534/lec6.pdf

logger = logging.getLogger(__name__)


def get_ion_multi_index(multi_index_full, next_higher=True):
    &quot;&quot;&quot;
    Calculate the corresponding ion MultiIndex for a level MultiIndex.

    Parameters
    ----------
    multi_index_full : pandas.MultiIndex (atomic_number, ion_number,
                                          level_number)
    next_higher : bool, default True
        If True use ion number of next higher ion, else use ion_number from
        multi_index_full.

    Returns
    -------
    pandas.MultiIndex (atomic_number, ion_number)
       Ion MultiIndex for the given level MultiIndex.
    &quot;&quot;&quot;
    atomic_number = multi_index_full.get_level_values(0)
    ion_number = multi_index_full.get_level_values(1)
    if next_higher is True:
        ion_number += 1
    return pd.MultiIndex.from_arrays([atomic_number, ion_number])


def get_ground_state_multi_index(multi_index_full):
    &quot;&quot;&quot;
    Calculate the ground-state MultiIndex for the next higher ion.

    Parameters
    ----------
    multi_index_full : pandas.MultiIndex (atomic_number, ion_number,
                                          level_number)

    Returns
    -------
    pandas.MultiIndex (atomic_number, ion_number)
        Ground-state MultiIndex for the next higher ion.
    &quot;&quot;&quot;
    atomic_number = multi_index_full.get_level_values(0)
    ion_number = multi_index_full.get_level_values(1) + 1
    level_number = np.zeros_like(ion_number)
    return pd.MultiIndex.from_arrays([atomic_number, ion_number, level_number])


def cooling_rate_series2dataframe(cooling_rate_series, destination_level_idx):
    &quot;&quot;&quot;
    Transform cooling-rate Series to DataFrame.

    This function transforms a Series with cooling rates into
    an indexed DataFrame that can be used in MarkovChainTransProbs.

    Parameters
    ----------
    cooling_rate_series : pandas.Series, dtype float
        Cooling rates for a process with a single destination idx.
        Examples are adiabatic cooling or free-free cooling.
    destination_level_idx : str
        Destination idx of the cooling process; for example
        &#39;adiabatic&#39; for adiabatic cooling.

    Returns
    -------
    cooling_rate_frame : pandas.DataFrame, dtype float
        Indexed by source_level_idx, destination_level_idx, transition_type
        for the use in MarkovChainTransProbs.
    &quot;&quot;&quot;
    index_names = [
        &quot;source_level_idx&quot;,
        &quot;destination_level_idx&quot;,
        &quot;transition_type&quot;,
    ]
    index = pd.MultiIndex.from_tuples(
        [(&quot;k&quot;, destination_level_idx, -1)], names=index_names
    )
    cooling_rate_frame = pd.DataFrame(
        cooling_rate_series.values[np.newaxis], index=index
    )
    return cooling_rate_frame


class IndexSetterMixin:
    @staticmethod
    def set_index(p, photo_ion_idx, transition_type=0, reverse=True):
        idx = photo_ion_idx.loc[p.index]
        transition_type = transition_type * np.ones_like(
            idx.destination_level_idx
        )
        transition_type = pd.Series(transition_type, name=&quot;transition_type&quot;)
        idx_arrays = [idx.source_level_idx, idx.destination_level_idx]
        if reverse:
            idx_arrays = idx_arrays[::-1]
        idx_arrays.append(transition_type)
        index = pd.MultiIndex.from_arrays(idx_arrays)
        if reverse:
            index.names = index.names[:-1][::-1] + [index.names[-1]]
        p = p.set_index(index, drop=True)
        return p


<div class="viewcode-block" id="SpontRecombCoolingRateCoeff">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.SpontRecombCoolingRateCoeff">[docs]</a>
class SpontRecombCoolingRateCoeff(ProcessingPlasmaProperty):
    &quot;&quot;&quot;
    Attributes
    ----------
    c_fb_sp : pandas.DataFrame, dtype float
        The rate coefficient for cooling by
        spontaneous recombination.
    &quot;&quot;&quot;

    outputs = (&quot;c_fb_sp&quot;,)
    latex_name = (r&quot;c^{\textrm{sp}}_{\textrm{fb}}&quot;,)

<div class="viewcode-block" id="SpontRecombCoolingRateCoeff.calculate">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.SpontRecombCoolingRateCoeff.calculate">[docs]</a>
    def calculate(
        self,
        photo_ion_cross_sections,
        t_electrons,
        photo_ion_block_references,
        photo_ion_index,
        phi_ik,
        nu_i,
        boltzmann_factor_photo_ion,
    ):
        x_sect = photo_ion_cross_sections[&quot;x_sect&quot;].values
        nu = photo_ion_cross_sections[&quot;nu&quot;].values
        factor = (1 - nu_i / photo_ion_cross_sections[&quot;nu&quot;]).values
        alpha_sp = (8 * np.pi * x_sect * factor * nu**3 / C**2) * H
        alpha_sp = alpha_sp[:, np.newaxis]
        alpha_sp = alpha_sp * boltzmann_factor_photo_ion
        alpha_sp = integrate_array_by_blocks(
            alpha_sp, nu, photo_ion_block_references
        )
        alpha_sp = pd.DataFrame(alpha_sp, index=photo_ion_index)
        return alpha_sp * phi_ik.loc[alpha_sp.index]</div>
</div>



<div class="viewcode-block" id="FreeBoundEmissionCDF">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.FreeBoundEmissionCDF">[docs]</a>
class FreeBoundEmissionCDF(ProcessingPlasmaProperty):
    &quot;&quot;&quot;
    Attributes
    ----------
    fb_emission_cdf : pandas.DataFrame, dtype float
        The cumulative distribution function (CDF) for the frequencies of
        energy packets emitted in free-bound transitions. The tabulated CDF
        is used to sample packet frequencies in the Monte Carlo simulation.
        We use the same CDF for free-bound emission from k- and i-packets
        (in contrast to ARTIS).
    &quot;&quot;&quot;

    outputs = (&quot;fb_emission_cdf&quot;,)
    latex_name = (r&quot;P(\nu_{bf, emission}) \leq \nu)&quot;,)

<div class="viewcode-block" id="FreeBoundEmissionCDF.calculate">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.FreeBoundEmissionCDF.calculate">[docs]</a>
    def calculate(
        self,
        photo_ion_cross_sections,
        t_electrons,
        photo_ion_block_references,
        photo_ion_index,
        nu_i,
        boltzmann_factor_photo_ion,
    ):
        x_sect = photo_ion_cross_sections[&quot;x_sect&quot;].values
        nu = photo_ion_cross_sections[&quot;nu&quot;].values
        # alpha_sp_E will be missing a lot of prefactors since we are only
        # interested in relative values here
        alpha_sp_E = nu**3 * x_sect
        alpha_sp_E = alpha_sp_E[:, np.newaxis]
        alpha_sp_E = alpha_sp_E * boltzmann_factor_photo_ion
        alpha_sp_E = cumulative_integrate_array_by_blocks(
            alpha_sp_E, nu, photo_ion_block_references
        )
        fb_emission_cdf = pd.DataFrame(
            alpha_sp_E, index=photo_ion_cross_sections.index
        )
        return fb_emission_cdf</div>
</div>



<div class="viewcode-block" id="RawRecombTransProbs">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.RawRecombTransProbs">[docs]</a>
class RawRecombTransProbs(TransitionProbabilitiesProperty, IndexSetterMixin):
    &quot;&quot;&quot;
    Attributes
    ----------
    p_recomb : pandas.DataFrame, dtype float
        The unnormalized transition probabilities for
        spontaneous recombination.
    &quot;&quot;&quot;

    outputs = (&quot;p_recomb&quot;,)
    transition_probabilities_outputs = (&quot;p_recomb&quot;,)
    latex_name = (r&quot;p^{\textrm{recomb}}&quot;,)

<div class="viewcode-block" id="RawRecombTransProbs.calculate">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.RawRecombTransProbs.calculate">[docs]</a>
    def calculate(self, alpha_sp, nu_i, energy_i, photo_ion_idx):
        p_recomb_deactivation = alpha_sp.multiply(nu_i, axis=0) * H
        p_recomb_deactivation = self.set_index(
            p_recomb_deactivation, photo_ion_idx, transition_type=-1
        )

        p_recomb_internal = alpha_sp.multiply(energy_i, axis=0)
        p_recomb_internal = self.set_index(
            p_recomb_internal, photo_ion_idx, transition_type=0
        )
        p_recomb = pd.concat([p_recomb_deactivation, p_recomb_internal])
        return p_recomb</div>
</div>



<div class="viewcode-block" id="RawPhotoIonTransProbs">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.RawPhotoIonTransProbs">[docs]</a>
class RawPhotoIonTransProbs(TransitionProbabilitiesProperty, IndexSetterMixin):
    &quot;&quot;&quot;
    Attributes
    ----------
    p_photo_ion : pandas.DataFrame, dtype float
        The unnormalized transition probabilities for
        radiative ionization.
    &quot;&quot;&quot;

    outputs = (&quot;p_photo_ion&quot;,)
    transition_probabilities_outputs = (&quot;p_photo_ion&quot;,)
    latex_name = (r&quot;p^{\textrm{photo_ion}}&quot;,)

<div class="viewcode-block" id="RawPhotoIonTransProbs.calculate">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.RawPhotoIonTransProbs.calculate">[docs]</a>
    def calculate(self, gamma_corr, energy_i, photo_ion_idx):
        p_photo_ion = gamma_corr.multiply(energy_i, axis=0)
        p_photo_ion = self.set_index(p_photo_ion, photo_ion_idx, reverse=False)
        return p_photo_ion</div>
</div>



<div class="viewcode-block" id="CorrPhotoIonRateCoeff">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.CorrPhotoIonRateCoeff">[docs]</a>
class CorrPhotoIonRateCoeff(ProcessingPlasmaProperty):
    &quot;&quot;&quot;
    Attributes
    ----------
    gamma_corr : pandas.DataFrame, dtype float
        The rate coefficient for radiative ionization corrected for
        stimulated recombination.
    &quot;&quot;&quot;

    outputs = (&quot;gamma_corr&quot;,)
    latex_name = (r&quot;\gamma_\mathrm{corr}&quot;,)

<div class="viewcode-block" id="CorrPhotoIonRateCoeff.calculate">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.CorrPhotoIonRateCoeff.calculate">[docs]</a>
    def calculate(
        self,
        gamma,
        alpha_stim,
        electron_densities,
        ion_number_density,
        level_number_density,
    ):
        n_k_index = get_ion_multi_index(alpha_stim.index)
        n_k = ion_number_density.loc[n_k_index].values
        n_i = level_number_density.loc[alpha_stim.index].values
        gamma_corr = gamma - (alpha_stim * n_k / n_i).multiply(
            electron_densities
        )
        num_neg_elements = (gamma_corr &lt; 0).sum().sum()
        if num_neg_elements:
            raise PlasmaException(
                &quot;Negative values in CorrPhotoIonRateCoeff.  Try raising the number of montecarlo packets.&quot;
            )
        return gamma_corr</div>
</div>



<div class="viewcode-block" id="StimRecombCoolingRateCoeffEstimator">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.StimRecombCoolingRateCoeffEstimator">[docs]</a>
class StimRecombCoolingRateCoeffEstimator(Input):
    &quot;&quot;&quot;
    Attributes
    ----------
    stim_recomb_cooling_coeff_estimator : pandas.DataFrame, dtype float
        Unnormalized MC estimator for the stimulated recombination cooling rate
        coefficient.
    &quot;&quot;&quot;

    outputs = (&quot;stim_recomb_cooling_coeff_estimator&quot;,)</div>



<div class="viewcode-block" id="BfHeatingRateCoeffEstimator">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.BfHeatingRateCoeffEstimator">[docs]</a>
class BfHeatingRateCoeffEstimator(Input):
    &quot;&quot;&quot;
    Attributes
    ----------
    bf_heating_coeff_estimator : pandas.DataFrame, dtype float
        Unnormalized MC estimator for the rate
        coefficient for bound-free heating.
    &quot;&quot;&quot;

    outputs = (&quot;bf_heating_coeff_estimator&quot;,)
    latex_name = (r&quot;h_\textrm{bf}_\textrm{estim}&quot;,)</div>



<div class="viewcode-block" id="CollExcRateCoeff">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.CollExcRateCoeff">[docs]</a>
class CollExcRateCoeff(ProcessingPlasmaProperty):
    &quot;&quot;&quot;
    Attributes
    ----------
    coll_exc_coeff : pandas.DataFrame, dtype float
        Rate coefficient for collisional excitation.
    &quot;&quot;&quot;

    outputs = (&quot;coll_exc_coeff&quot;,)
    latex_name = (&quot;c_{lu}&quot;,)

<div class="viewcode-block" id="CollExcRateCoeff.calculate">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.CollExcRateCoeff.calculate">[docs]</a>
    def calculate(self, yg_interp, yg_index, t_electrons, delta_E_yg):
        yg = yg_interp(t_electrons)
        boltzmann_factor = np.exp(
            -delta_E_yg.values[np.newaxis].T / (t_electrons * K_B)
        )
        q_ij = (
            BETA_COLL / np.sqrt(t_electrons) * yg * boltzmann_factor
        )  # see formula A2 in Przybilla, Butler 2004 - Apj 609, 1181
        return pd.DataFrame(q_ij, index=yg_index)</div>
</div>



<div class="viewcode-block" id="CollDeexcRateCoeff">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.CollDeexcRateCoeff">[docs]</a>
class CollDeexcRateCoeff(ProcessingPlasmaProperty):
    &quot;&quot;&quot;
    Attributes
    ----------
    coll_deexc_coeff : pandas.DataFrame, dtype float
        Rate coefficient for collisional deexcitation.
    &quot;&quot;&quot;

    outputs = (&quot;coll_deexc_coeff&quot;,)
    latex_name = (&quot;c_{ul}&quot;,)

<div class="viewcode-block" id="CollDeexcRateCoeff.calculate">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.CollDeexcRateCoeff.calculate">[docs]</a>
    def calculate(self, thermal_lte_level_boltzmann_factor, coll_exc_coeff):
        level_lower_index = coll_exc_coeff.index.droplevel(&quot;level_number_upper&quot;)
        level_upper_index = coll_exc_coeff.index.droplevel(&quot;level_number_lower&quot;)

        n_lower_prop = thermal_lte_level_boltzmann_factor.loc[
            level_lower_index
        ].values
        n_upper_prop = thermal_lte_level_boltzmann_factor.loc[
            level_upper_index
        ].values

        coll_deexc_coeff = coll_exc_coeff * n_lower_prop / n_upper_prop
        return coll_deexc_coeff</div>
</div>



<div class="viewcode-block" id="RawCollisionTransProbs">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.RawCollisionTransProbs">[docs]</a>
class RawCollisionTransProbs(TransitionProbabilitiesProperty, IndexSetterMixin):
    &quot;&quot;&quot;
    Attributes
    ----------
    p_coll : pandas.DataFrame, dtype float
        The unnormalized transition probabilities for
        collisional excitation.
    &quot;&quot;&quot;

    outputs = (&quot;p_coll&quot;,)
    transition_probabilities_outputs = (&quot;p_coll&quot;,)
    latex_name = (r&quot;p^{\textrm{coll}}&quot;,)

<div class="viewcode-block" id="RawCollisionTransProbs.calculate">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.RawCollisionTransProbs.calculate">[docs]</a>
    def calculate(
        self,
        coll_exc_coeff,
        coll_deexc_coeff,
        yg_idx,
        electron_densities,
        delta_E_yg,
        atomic_data,
        level_number_density,
    ):
        p_deexc_deactivation = (coll_deexc_coeff * electron_densities).multiply(
            delta_E_yg.values, axis=0
        )
        p_deexc_deactivation = self.set_index(
            p_deexc_deactivation, yg_idx, reverse=True
        )
        p_deexc_deactivation = p_deexc_deactivation.groupby(level=[0]).sum()
        index_dd = pd.MultiIndex.from_product(
            [p_deexc_deactivation.index.values, [&quot;k&quot;], [0]],
            names=list(yg_idx.columns) + [&quot;transition_type&quot;],
        )
        p_deexc_deactivation = p_deexc_deactivation.set_index(index_dd)

        level_lower_index = coll_deexc_coeff.index.droplevel(
            &quot;level_number_upper&quot;
        )
        energy_lower = atomic_data.levels.energy.loc[level_lower_index]
        p_deexc_internal = (coll_deexc_coeff * electron_densities).multiply(
            energy_lower.values, axis=0
        )
        p_deexc_internal = self.set_index(
            p_deexc_internal, yg_idx, transition_type=0, reverse=True
        )

        p_exc_internal = (coll_exc_coeff * electron_densities).multiply(
            energy_lower.values, axis=0
        )
        p_exc_internal = self.set_index(
            p_exc_internal, yg_idx, transition_type=0, reverse=False
        )
        p_exc_cool = (coll_exc_coeff * electron_densities).multiply(
            delta_E_yg.values, axis=0
        )
        p_exc_cool = (
            p_exc_cool * level_number_density.loc[level_lower_index].values
        )
        p_exc_cool = self.set_index(p_exc_cool, yg_idx, reverse=False)
        p_exc_cool = p_exc_cool.groupby(level=&quot;destination_level_idx&quot;).sum()
        exc_cool_index = pd.MultiIndex.from_product(
            [[&quot;k&quot;], p_exc_cool.index.values, [0]],
            names=list(yg_idx.columns) + [&quot;transition_type&quot;],
        )
        p_exc_cool = p_exc_cool.set_index(exc_cool_index)
        p_coll = pd.concat(
            [p_deexc_deactivation, p_deexc_internal, p_exc_internal, p_exc_cool]
        )
        return p_coll</div>
</div>



<div class="viewcode-block" id="RawTwoPhotonTransProbs">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.RawTwoPhotonTransProbs">[docs]</a>
class RawTwoPhotonTransProbs(TransitionProbabilitiesProperty, IndexSetterMixin):
    &quot;&quot;&quot;
    Attributes
    ----------
    p_two_photon : pandas.DataFrame, dtype float
        The unnormalized transition probabilities for two photon decay.
    &quot;&quot;&quot;

    outputs = (&quot;p_two_photon&quot;,)
    transition_probabilities_outputs = (&quot;p_two_photon&quot;,)

<div class="viewcode-block" id="RawTwoPhotonTransProbs.calculate">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.RawTwoPhotonTransProbs.calculate">[docs]</a>
    def calculate(self, two_photon_data, two_photon_idx, density):
        no_shells = len(density)
        p_two_phot = two_photon_data.A_ul * two_photon_data.nu0 * H
        p_two_phot = pd.concat([p_two_phot] * no_shells, axis=1)
        # TODO: In principle there could be internal two photon transitions
        p_two_phot = self.set_index(
            p_two_phot,
            two_photon_idx,
            transition_type=-1,
            reverse=False,
        )
        p_two_phot.index = p_two_phot.index.set_levels(
            [&quot;two-photon&quot;], level=&quot;destination_level_idx&quot;
        )
        return p_two_phot</div>
</div>



<div class="viewcode-block" id="TwoPhotonEmissionCDF">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.TwoPhotonEmissionCDF">[docs]</a>
class TwoPhotonEmissionCDF(ProcessingPlasmaProperty):
    &quot;&quot;&quot;
    Attributes
    ----------
    two_photon_emission_cdf : pandas.DataFrame, dtype float
        The cumulative distribution function (CDF) for the frequencies of
        energy packets emitted in two photon transitions. The tabulated CDF
        is used to sample packet frequencies in the Monte Carlo simulation.
    &quot;&quot;&quot;

    outputs = (&quot;two_photon_emission_cdf&quot;,)

<div class="viewcode-block" id="TwoPhotonEmissionCDF.calculate">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.TwoPhotonEmissionCDF.calculate">[docs]</a>
    def calculate(self, two_photon_data):
        bins = 500
        # The number of two photon transitions is very small
        # and the CDF has to be calculated only once.
        # There is no need to vectorize the calculation.
        emission_cdfs = []
        for index, row in two_photon_data.iterrows():
            alpha = row.alpha
            beta = row.beta
            gamma = row.gamma
            nu = np.linspace(0.0, row.nu0, bins)
            y = nu / row.nu0
            j_nu = self.calculate_j_nu(y, alpha, beta, gamma)

            cdf = np.zeros_like(nu)
            cdf[1:] = numba_cumulative_trapezoid(j_nu, nu)
            cdf /= cdf[-1]
            index_cdf = pd.MultiIndex.from_tuples([index] * bins)
            cdf = pd.DataFrame({&quot;nu&quot;: nu, &quot;cdf&quot;: cdf}, index=index_cdf)
            emission_cdfs.append(cdf)
        return pd.concat(emission_cdfs)</div>


<div class="viewcode-block" id="TwoPhotonEmissionCDF.calculate_j_nu">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.TwoPhotonEmissionCDF.calculate_j_nu">[docs]</a>
    @staticmethod
    def calculate_j_nu(y, alpha, beta, gamma):
        &quot;&quot;&quot;
        Calculate two photon emissivity.

        This function calculates the two photon emissivity in the frequency
        scale based on Eq. 2 and Eq. 3 in Nussbaumer &amp; Schmutz (1984). The
        emissivity is not normalized since it is only used to calculate
        relative emission probabilities.

        Parameters
        ----------
        y : numpy.ndarray, dtype float
            Emission frequency divided by that of the normal line
            transition corresponding to the two photon decay.
        alpha : float
            Fit coefficient.
        beta : float
            Fit coefficient.
        gamma : float
            Fit coefficient.

        Returns
        -------
        numpy.ndarray, dtype float
            Unnormalized two photon emissivity in the frequency scale.
        &quot;&quot;&quot;
        ay = y * (1 - y) * (1 - (4 * y * (1 - y)) ** gamma)
        ay += alpha * (y * (1 - y)) ** beta * (4 * y * (1 - y)) ** gamma
        j_nu = ay * y
        return j_nu</div>
</div>



<div class="viewcode-block" id="AdiabaticCoolingRate">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.AdiabaticCoolingRate">[docs]</a>
class AdiabaticCoolingRate(TransitionProbabilitiesProperty):
    &quot;&quot;&quot;
    Attributes
    ----------
    cool_rate_adiabatic : pandas.DataFrame, dtype float
        The adiabatic cooling rate of the electron gas.
    &quot;&quot;&quot;

    outputs = (&quot;cool_rate_adiabatic&quot;,)
    transition_probabilities_outputs = (&quot;cool_rate_adiabatic&quot;,)
    latex_name = (r&quot;C_{\textrm{adiabatic}}&quot;,)

<div class="viewcode-block" id="AdiabaticCoolingRate.calculate">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.AdiabaticCoolingRate.calculate">[docs]</a>
    def calculate(self, electron_densities, t_electrons, time_explosion):
        cool_rate_adiabatic = (
            3.0 * electron_densities * K_B * t_electrons
        ) / time_explosion

        cool_rate_adiabatic = cooling_rate_series2dataframe(
            cool_rate_adiabatic, destination_level_idx=&quot;adiabatic&quot;
        )
        return cool_rate_adiabatic</div>
</div>



<div class="viewcode-block" id="FreeFreeCoolingRate">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.FreeFreeCoolingRate">[docs]</a>
class FreeFreeCoolingRate(TransitionProbabilitiesProperty):
    &quot;&quot;&quot;
    Attributes
    ----------
    cool_rate_ff : pandas.DataFrame, dtype float
        The free-free cooling rate of the electron gas.
    ff_cooling_factor : pandas.Series, dtype float
        Pre-factor needed in the calculation of the free-free cooling rate and
        the free-free opacity.

    Notes
    -----
    This implementation uses a free-free Gaunt factor of one for all species
    and ionization stages, which is an approximation.
    &quot;&quot;&quot;

    outputs = (&quot;cool_rate_ff&quot;, &quot;ff_cooling_factor&quot;)
    transition_probabilities_outputs = (&quot;cool_rate_ff&quot;,)
    latex_name = (r&quot;C^{\textrm{ff}}&quot;,)

<div class="viewcode-block" id="FreeFreeCoolingRate.calculate">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.FreeFreeCoolingRate.calculate">[docs]</a>
    def calculate(self, ion_number_density, electron_densities, t_electrons):
        ff_cooling_factor = self._calculate_ff_cooling_factor(
            ion_number_density, electron_densities
        )
        cool_rate_ff = F_K * np.sqrt(t_electrons) * ff_cooling_factor
        cool_rate_ff = cooling_rate_series2dataframe(
            cool_rate_ff, destination_level_idx=&quot;ff&quot;
        )
        return cool_rate_ff, ff_cooling_factor.values</div>


    @staticmethod
    def _calculate_ff_cooling_factor(ion_number_density, electron_densities):
        ion_charge = ion_number_density.index.get_level_values(1).values
        factor = (
            electron_densities
            * ion_number_density.multiply(ion_charge**2, axis=0).sum()
        )
        return factor</div>



<div class="viewcode-block" id="TwoPhotonFrequencySampler">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.TwoPhotonFrequencySampler">[docs]</a>
class TwoPhotonFrequencySampler(ProcessingPlasmaProperty):
    &quot;&quot;&quot;
    Attributes
    ----------
    nu_two_photon_sampler : float
        Frequency of the two-photon emission process
    &quot;&quot;&quot;

    outputs = (&quot;nu_two_photon_sampler&quot;,)

<div class="viewcode-block" id="TwoPhotonFrequencySampler.calculate">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.TwoPhotonFrequencySampler.calculate">[docs]</a>
    def calculate(self, two_photon_emission_cdf):
        nus = two_photon_emission_cdf[&quot;nu&quot;].values
        em = two_photon_emission_cdf[&quot;cdf&quot;].values

        @njit(error_model=&quot;numpy&quot;, fastmath=True)
        def nu_two_photon():
            zrand = np.random.random()
            idx = np.searchsorted(em, zrand, side=&quot;right&quot;)

            return nus[idx] - (em[idx] - zrand) / (em[idx] - em[idx - 1]) * (
                nus[idx] - nus[idx - 1]
            )

        return nu_two_photon</div>
</div>



<div class="viewcode-block" id="FreeBoundCoolingRate">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.FreeBoundCoolingRate">[docs]</a>
class FreeBoundCoolingRate(TransitionProbabilitiesProperty):
    &quot;&quot;&quot;
    Attributes
    ----------
    cool_rate_fb_total : pandas.DataFrame, dtype float
        The total free-bound cooling rate of the electron gas.
    cool_rate_fb : pandas.DataFrame, dtype float
        The individual free-bound cooling rates of the electron gas.
    p_fb_deactivation: pandas.DataFrame, dtype float
        Probabilities of free-bound cooling in a specific continuum
        (identified by its continuum_idx).
    &quot;&quot;&quot;

    outputs = (&quot;cool_rate_fb_tot&quot;, &quot;cool_rate_fb&quot;, &quot;p_fb_deactivation&quot;)
    transition_probabilities_outputs = (&quot;cool_rate_fb_tot&quot;,)
    latex_name = (r&quot;C^{\textrm{fb, tot}}&quot;, r&quot;C^{\textrm{fb}}&quot;)

<div class="viewcode-block" id="FreeBoundCoolingRate.calculate">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.FreeBoundCoolingRate.calculate">[docs]</a>
    def calculate(
        self,
        c_fb_sp,
        electron_densities,
        ion_number_density,
        level2continuum_idx,
    ):
        next_ion_stage_index = get_ion_multi_index(c_fb_sp.index)
        n_k = ion_number_density.loc[next_ion_stage_index]

        cool_rate_fb = c_fb_sp.multiply(electron_densities, axis=1) * n_k.values
        cool_rate_fb_tot = cooling_rate_series2dataframe(
            cool_rate_fb.sum(axis=0), &quot;bf&quot;
        )

        p_fb_deactivation = cool_rate_fb / cool_rate_fb_tot.values
        # TODO: this will be needed more often; put it in a function
        continuum_idx = level2continuum_idx.loc[p_fb_deactivation.index].values
        p_fb_deactivation = p_fb_deactivation.set_index(
            continuum_idx
        ).sort_index(ascending=True, kind=SORTING_ALGORITHM)
        p_fb_deactivation.index.name = &quot;continuum_idx&quot;
        return cool_rate_fb_tot, cool_rate_fb, p_fb_deactivation</div>
</div>



<div class="viewcode-block" id="LevelNumberDensityLTE">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.LevelNumberDensityLTE">[docs]</a>
class LevelNumberDensityLTE(ProcessingPlasmaProperty):
    &quot;&quot;&quot;
    Attributes
    ----------
    lte_level_number_density : pandas.DataFrame, dtype float
    &quot;&quot;&quot;

    outputs = (&quot;lte_level_number_density&quot;,)
    latex_name = (r&quot;n_{\textrm{i}}^*&quot;,)

    # TODO: only do this for continuum species
<div class="viewcode-block" id="LevelNumberDensityLTE.calculate">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.LevelNumberDensityLTE.calculate">[docs]</a>
    def calculate(self, electron_densities, phi_ik, ion_number_density):
        next_higher_ion_index = get_ion_multi_index(
            phi_ik.index, next_higher=True
        )
        # TODO: Check that n_k is correct (and not n_k*)
        lte_level_number_density = (
            phi_ik * ion_number_density.loc[next_higher_ion_index].values
        ).multiply(electron_densities, axis=1)
        return lte_level_number_density</div>
</div>



<div class="viewcode-block" id="PhotoIonBoltzmannFactor">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.PhotoIonBoltzmannFactor">[docs]</a>
class PhotoIonBoltzmannFactor(ProcessingPlasmaProperty):
    &quot;&quot;&quot;
    Attributes
    ----------
    boltzmann_factor_photo_ion : pandas.DataFrame, dtype float
    &quot;&quot;&quot;

    outputs = (&quot;boltzmann_factor_photo_ion&quot;,)

<div class="viewcode-block" id="PhotoIonBoltzmannFactor.calculate">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.PhotoIonBoltzmannFactor.calculate">[docs]</a>
    @staticmethod
    def calculate(photo_ion_cross_sections, t_electrons):
        nu = photo_ion_cross_sections[&quot;nu&quot;].values

        boltzmann_factor = np.exp(-nu[np.newaxis].T / t_electrons * (H / K_B))
        return boltzmann_factor</div>
</div>



<div class="viewcode-block" id="CollIonRateCoeffSeaton">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.CollIonRateCoeffSeaton">[docs]</a>
class CollIonRateCoeffSeaton(ProcessingPlasmaProperty):
    &quot;&quot;&quot;
    Attributes
    ----------
    coll_ion_coeff : pandas.DataFrame, dtype float
        The rate coefficient for collisional ionization in the Seaton
        approximation. Multiply with the electron density and the
        level number density to obtain the total rate.

    Notes
    -----
    The rate coefficient for collisional ionization in the Seaton approximation
    is calculated according to Eq. 9.60 in [1].

    References
    ----------
    .. [1] Hubeny, I. and Mihalas, D., &quot;Theory of Stellar Atmospheres&quot;. 2014.
    &quot;&quot;&quot;

    outputs = (&quot;coll_ion_coeff&quot;,)
    latex_name = (r&quot;c_{\textrm{i,}\kappa}&quot;,)

<div class="viewcode-block" id="CollIonRateCoeffSeaton.calculate">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.CollIonRateCoeffSeaton.calculate">[docs]</a>
    def calculate(self, photo_ion_cross_sections, t_electrons):
        photo_ion_cross_sections_threshold = photo_ion_cross_sections.groupby(
            level=[0, 1, 2]
        ).first()
        nu_i = photo_ion_cross_sections_threshold[&quot;nu&quot;]
        factor = self._calculate_factor(nu_i, t_electrons)
        coll_ion_coeff = 1.55e13 * photo_ion_cross_sections_threshold[&quot;x_sect&quot;]
        coll_ion_coeff = factor.multiply(coll_ion_coeff, axis=0)
        coll_ion_coeff = coll_ion_coeff.divide(np.sqrt(t_electrons), axis=1)

        ion_number = coll_ion_coeff.index.get_level_values(&quot;ion_number&quot;).values
        coll_ion_coeff[ion_number == 0] *= 0.1
        coll_ion_coeff[ion_number == 1] *= 0.2
        coll_ion_coeff[ion_number &gt;= 2] *= 0.3
        return coll_ion_coeff</div>


    def _calculate_factor(self, nu_i, t_electrons):
        u0s = self._calculate_u0s(nu_i.values, t_electrons)
        factor = np.exp(-u0s) / u0s
        factor = pd.DataFrame(factor, index=nu_i.index)
        return factor

    @staticmethod
    def _calculate_u0s(nu, t_electrons):
        u0s = nu[np.newaxis].T / t_electrons * (H / K_B)
        return u0s</div>



<div class="viewcode-block" id="CollRecombRateCoeff">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.CollRecombRateCoeff">[docs]</a>
class CollRecombRateCoeff(ProcessingPlasmaProperty):
    &quot;&quot;&quot;
    Attributes
    ----------
    coll_recomb_coeff : pandas.DataFrame, dtype float
        The rate coefficient for collisional recombination.
        Multiply with the electron density squared and the ion number density
        to obtain the total rate.

    Notes
    -----
    The collisional recombination rate coefficient is calculated from the
    collisional ionization rate coefficient based on the requirement of detailed
    balance.
    &quot;&quot;&quot;

    outputs = (&quot;coll_recomb_coeff&quot;,)
    latex_name = (r&quot;c_{\kappa\textrm{i,}}&quot;,)

<div class="viewcode-block" id="CollRecombRateCoeff.calculate">
<a class="viewcode-back" href="../../../../../api/tardis.plasma.properties.continuum_processes.rates.html#tardis.plasma.properties.continuum_processes.rates.CollRecombRateCoeff.calculate">[docs]</a>
    def calculate(self, phi_ik, coll_ion_coeff):
        return coll_ion_coeff.multiply(phi_ik.loc[coll_ion_coeff.index])</div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2013-2025, TARDIS Collaboration.
      <span class="lastupdated">Last updated on 12 Oct 2025.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>