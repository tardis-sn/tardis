

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-53HJHD1BWS"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-53HJHD1BWS');
    </script>
    
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>tardis.simulation.base &mdash; tardis</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />

  
    <link rel="shortcut icon" href="../../../_static/tardis_logo.ico"/>
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=3d5d8261"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@1.0.13/dist/embed-amd.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link href="../../../_static/tardis.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            tardis
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart.html">Quickstart for TARDIS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../resources/credits.html">Credits &amp; Publication Policies</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/high_energy/run_high_energy_workflow.html">TARDIS High Energy Workflow Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../analyzing_tardis/visualization/tutorial_montecarlo_packet_visualization.html">Montecarlo Packet Visualization</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">How-to Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../how_to_guides.html">How-To Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../workflows.html">Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../analyzing_tardis/index.html">Analyszing TARDIS Simulation Outputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../io/configuration/tutorial_read_configuration.html">Reading a Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../io/optional/index.html">Optional Inputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../io/output/index.html">Additional Outputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../how-to/code_comparison/index.html">How to do Code Comparison using TARDIS</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Physics Walkthrough</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../physics_walkthrough/intro/index.html">Physics Walkthrough Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../physics_walkthrough/setup/index.html">Setting Up the Simulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../physics_walkthrough/montecarlo/index.html">Monte Carlo Iteration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../physics_walkthrough/update_and_conv/update_and_conv.html">Updating Plasma and Convergence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../physics_walkthrough/spectrum/index.html">Spectrum Generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../physics_walkthrough/tardisgamma/index.html">TARDIS-High Energy</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/modules.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/visualization_reference.html">Visualization Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../io/configuration/index.html">Configuration Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../io/hdf/index.html">Hierarchical Data Format (HDF5) Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing/CHANGELOG.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../resources/research_done_using_TARDIS/research_papers.html">Papers Using TARDIS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../resources/zreferences.html">Bibliography and Glossary</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contributing to TARDIS</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing/CONTRIBUTING.html">Contribution Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing/development/index.html">Developer Workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing/tools/index.html">Developer Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing/in_progress/index.html">Features In-Progress</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">tardis</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">tardis.simulation.base</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for tardis.simulation.base</h1><div class="highlight"><pre>
<span></span>import logging
import time
from collections import OrderedDict

import numpy as np
import pandas as pd
from astropy import units as u

import tardis
from tardis import constants as const
from tardis.io.configuration.config_reader import ConfigurationError
from tardis.io.hdf_writer_mixin import HDFWriterMixin
from tardis.io.model.parse_atom_data import parse_atom_data
from tardis.io.model.parse_simulation_state import (
    parse_simulation_state,
)
from tardis.opacities.macro_atom.macroatom_solver import (
    LegacyMacroAtomSolver,
    BoundBoundMacroAtomSolver,
)
from tardis.opacities.macro_atom.macroatom_state import LegacyMacroAtomState
from tardis.opacities.opacity_solver import OpacitySolver
from tardis.plasma.assembly.legacy_assembly import assemble_plasma
from tardis.plasma.radiation_field import DilutePlanckianRadiationField
from tardis.simulation.convergence import ConvergenceSolver
from tardis.spectrum.base import SpectrumSolver
from tardis.spectrum.formal_integral.formal_integral_solver import (
    FormalIntegralSolver,
)
from tardis.spectrum.luminosity import (
    calculate_filtered_luminosity,
)
from tardis.transport.montecarlo.base import MonteCarloTransportSolver
from tardis.transport.montecarlo.configuration import montecarlo_globals
from tardis.transport.montecarlo.estimators.continuum_radfield_properties import (
    MCContinuumPropertiesSolver,
)
from tardis.transport.montecarlo.progress_bars import initialize_iterations_pbar
from tardis.util.environment import Environment
from tardis.visualization import ConvergencePlots

logger = logging.getLogger(__name__)


<div class="viewcode-block" id="PlasmaStateStorerMixin">
<a class="viewcode-back" href="../../../api/tardis.simulation.base.html#tardis.simulation.base.PlasmaStateStorerMixin">[docs]</a>
class PlasmaStateStorerMixin:
    &quot;&quot;&quot;Mixin class to provide the capability to the simulation object of
    storing plasma information and the inner boundary temperature during each
    MC iteration.

    Currently, storage for the dilution factor, the radiation temperature and
    the electron density in each cell is provided. Additionally, the
    temperature at the inner boundary is saved.
    &quot;&quot;&quot;

    def __init__(self, iterations, no_of_shells):
        self.iterations_w = np.zeros((iterations, no_of_shells))
        self.iterations_t_rad = np.zeros((iterations, no_of_shells)) * u.K
        self.iterations_electron_densities = np.zeros(
            (iterations, no_of_shells)
        )
        self.iterations_t_inner = np.zeros(iterations) * u.K

<div class="viewcode-block" id="PlasmaStateStorerMixin.store_plasma_state">
<a class="viewcode-back" href="../../../api/tardis.simulation.base.html#tardis.simulation.base.PlasmaStateStorerMixin.store_plasma_state">[docs]</a>
    def store_plasma_state(self, i, w, t_rad, electron_densities, t_inner):
        &quot;&quot;&quot;Store current plasma information and inner boundary temperature
        used in iterated i.

        Parameters
        ----------
        i : int
            current iteration index (0 for the first)
        w : np.ndarray
            dilution factor
        t_rad : astropy.units.Quantity
            radiation temperature
        electron_densities : np.ndarray
            electron density
        t_inner : astropy.units.Quantity
            temperature of inner boundary
        &quot;&quot;&quot;
        self.iterations_w[i, :] = w
        self.iterations_t_rad[i, :] = t_rad
        self.iterations_electron_densities[i, :] = electron_densities.values
        self.iterations_t_inner[i] = t_inner</div>


<div class="viewcode-block" id="PlasmaStateStorerMixin.reshape_plasma_state_store">
<a class="viewcode-back" href="../../../api/tardis.simulation.base.html#tardis.simulation.base.PlasmaStateStorerMixin.reshape_plasma_state_store">[docs]</a>
    def reshape_plasma_state_store(self, executed_iterations):
        &quot;&quot;&quot;Reshapes the storage arrays in case convergence was reached before
        all specified iterations were executed.

        Parameters
        ----------
        executed_iterations : int
            iteration index, i.e. number of iterations executed minus one!
        &quot;&quot;&quot;
        self.iterations_w = self.iterations_w[: executed_iterations + 1, :]
        self.iterations_t_rad = self.iterations_t_rad[
            : executed_iterations + 1, :
        ]
        self.iterations_electron_densities = self.iterations_electron_densities[
            : executed_iterations + 1, :
        ]
        self.iterations_t_inner = self.iterations_t_inner[
            : executed_iterations + 1
        ]</div>
</div>



<div class="viewcode-block" id="Simulation">
<a class="viewcode-back" href="../../../api/tardis.simulation.base.html#tardis.simulation.base.Simulation">[docs]</a>
class Simulation(PlasmaStateStorerMixin, HDFWriterMixin):
    &quot;&quot;&quot;A composite object containing all the required information for a
    simulation.

    Parameters
    ----------
    converged : bool
    iterations : int
    model : tardis.model.SimulationState
    plasma : tardis.plasma.BasePlasma
    transport : tardis.transport.montecarlo.MontecarloTransport
    opacity : tardis.opacities.opacity_solver.OpacitySolver
    macro_atom : tardis.opacities.macro_atom.macroatom_solver.LegacyMacroAtomSolver
    no_of_packets : int
    last_no_of_packets : int
    no_of_virtual_packets : int
    luminosity_nu_start : astropy.units.Quantity
    luminosity_nu_end : astropy.units.Quantity
    luminosity_requested : astropy.units.Quantity
    convergence_plots_kwargs: dict
    &quot;&quot;&quot;

    hdf_properties = [
        &quot;simulation_state&quot;,
        &quot;plasma&quot;,
        &quot;transport&quot;,
        &quot;iterations_w&quot;,
        &quot;iterations_t_rad&quot;,
        &quot;iterations_electron_densities&quot;,
        &quot;iterations_t_inner&quot;,
        &quot;spectrum_solver&quot;,
    ]
    hdf_name = &quot;simulation&quot;

    def __init__(
        self,
        iterations,
        simulation_state,
        plasma,
        transport,
        opacity,
        macro_atom,
        no_of_packets,
        no_of_virtual_packets,
        luminosity_nu_start,
        luminosity_nu_end,
        last_no_of_packets,
        luminosity_requested,
        convergence_strategy,
        show_convergence_plots,
        convergence_plots_kwargs,
        show_progress_bars,
        spectrum_solver,
    ):
        super().__init__(iterations, simulation_state.no_of_shells)

        self.converged = False
        self.iterations = iterations
        self.iterations_executed = 0
        self.simulation_state = simulation_state
        self.plasma = plasma
        self.transport = transport
        self.opacity = opacity
        self.macro_atom = macro_atom
        self.no_of_packets = no_of_packets
        self.last_no_of_packets = last_no_of_packets
        self.no_of_virtual_packets = no_of_virtual_packets
        self.luminosity_nu_start = luminosity_nu_start
        self.luminosity_nu_end = luminosity_nu_end
        self.luminosity_requested = luminosity_requested
        self.spectrum_solver = spectrum_solver
        self.show_progress_bars = show_progress_bars
        self.version = tardis.__version__

        # Convergence
        self.convergence_strategy = convergence_strategy
        self.converged = False
        self.consecutive_converges_count = 0

        # Convergence solvers
        self.t_rad_convergence_solver = ConvergenceSolver(
            self.convergence_strategy.t_rad
        )
        self.w_convergence_solver = ConvergenceSolver(
            self.convergence_strategy.w
        )
        self.t_inner_convergence_solver = ConvergenceSolver(
            self.convergence_strategy.t_inner
        )

        if show_convergence_plots:
            if not Environment.allows_widget_display():
                raise RuntimeError(
                    &quot;Convergence Plots cannot be displayed in command-line. Set show_convergence_plots &quot;
                    &quot;to False.&quot;
                )
            self.convergence_plots = ConvergencePlots(
                iterations=self.iterations, **convergence_plots_kwargs
            )

        if &quot;export_convergence_plots&quot; in convergence_plots_kwargs:
            if not isinstance(
                convergence_plots_kwargs[&quot;export_convergence_plots&quot;],
                bool,
            ):
                raise TypeError(
                    &quot;Expected bool in export_convergence_plots argument&quot;
                )
            self.export_convergence_plots = convergence_plots_kwargs[
                &quot;export_convergence_plots&quot;
            ]
        else:
            self.export_convergence_plots = False

        self._callbacks = OrderedDict()
        self._cb_next_id = 0

        montecarlo_globals.CONTINUUM_PROCESSES_ENABLED = (
            not self.plasma.continuum_interaction_species.empty
        )

<div class="viewcode-block" id="Simulation.estimate_t_inner">
<a class="viewcode-back" href="../../../api/tardis.simulation.base.html#tardis.simulation.base.Simulation.estimate_t_inner">[docs]</a>
    def estimate_t_inner(
        self,
        input_t_inner,
        luminosity_requested,
        emitted_luminosity,
        t_inner_update_exponent=-0.5,
    ):
        luminosity_ratios = (
            (emitted_luminosity / luminosity_requested).to(1).value
        )

        return input_t_inner * luminosity_ratios**t_inner_update_exponent</div>


    def _get_convergence_status(
        self, t_rad, w, t_inner, estimated_t_rad, estimated_w, estimated_t_inner
    ):
        t_rad_converged = self.t_rad_convergence_solver.get_convergence_status(
            t_rad.value,
            estimated_t_rad.value,
            self.simulation_state.no_of_shells,
        )

        w_converged = self.w_convergence_solver.get_convergence_status(
            w, estimated_w, self.simulation_state.no_of_shells
        )

        t_inner_converged = (
            self.t_inner_convergence_solver.get_convergence_status(
                t_inner.value,
                estimated_t_inner.value,
                1,
            )
        )

        if np.all([t_rad_converged, w_converged, t_inner_converged]):
            hold_iterations = self.convergence_strategy.hold_iterations
            self.consecutive_converges_count += 1
            logger.info(
                f&quot;Iteration converged {self.consecutive_converges_count:d}/{(hold_iterations + 1):d} consecutive &quot;
                f&quot;times.&quot;
            )
            # If an iteration has converged, require hold_iterations more
            # iterations to converge before we conclude that the Simulation
            # is converged.
            return self.consecutive_converges_count == hold_iterations + 1
        self.consecutive_converges_count = 0
        return False

<div class="viewcode-block" id="Simulation.advance_state">
<a class="viewcode-back" href="../../../api/tardis.simulation.base.html#tardis.simulation.base.Simulation.advance_state">[docs]</a>
    def advance_state(self, emitted_luminosity):
        &quot;&quot;&quot;
        Advances the state of the model and the plasma for the next
        iteration of the simulation. Returns True if the convergence criteria
        are met, else False.

        Returns
        -------
            converged : bool
        &quot;&quot;&quot;
        estimated_radfield_properties = (
            self.transport.radfield_prop_solver.solve(
                self.transport.transport_state.radfield_mc_estimators,
                self.transport.transport_state.time_explosion,
                self.transport.transport_state.time_of_simulation,
                self.transport.transport_state.geometry_state.volume,
                self.transport.transport_state.opacity_state.line_list_nu,
            )
        )

        estimated_t_rad = estimated_radfield_properties.dilute_blackbody_radiationfield_state.temperature
        estimated_dilution_factor = estimated_radfield_properties.dilute_blackbody_radiationfield_state.dilution_factor

        estimated_t_inner = self.estimate_t_inner(
            self.simulation_state.t_inner,
            self.luminosity_requested,
            emitted_luminosity,
            t_inner_update_exponent=self.convergence_strategy.t_inner_update_exponent,
        )

        converged = self._get_convergence_status(
            self.simulation_state.t_radiative,
            self.simulation_state.dilution_factor,
            self.simulation_state.t_inner,
            estimated_t_rad,
            estimated_dilution_factor,
            estimated_t_inner,
        )

        # calculate_next_plasma_state equivalent
        next_t_radiative = self.t_rad_convergence_solver.converge(
            self.simulation_state.t_radiative,
            estimated_t_rad,
        )
        next_dilution_factor = self.w_convergence_solver.converge(
            self.simulation_state.dilution_factor,
            estimated_dilution_factor,
        )
        if (
            self.iterations_executed + 1
        ) % self.convergence_strategy.lock_t_inner_cycles == 0:
            next_t_inner = self.t_inner_convergence_solver.converge(
                self.simulation_state.t_inner,
                estimated_t_inner,
            )
        else:
            next_t_inner = self.simulation_state.t_inner

        if hasattr(self, &quot;convergence_plots&quot;):
            self.convergence_plots.fetch_data(
                name=&quot;t_inner&quot;,
                value=self.simulation_state.t_inner.value,
                item_type=&quot;value&quot;,
            )
            self.convergence_plots.fetch_data(
                name=&quot;t_rad&quot;,
                value=self.simulation_state.t_radiative,
                item_type=&quot;iterable&quot;,
            )
            self.convergence_plots.fetch_data(
                name=&quot;w&quot;,
                value=self.simulation_state.dilution_factor,
                item_type=&quot;iterable&quot;,
            )
            self.convergence_plots.fetch_data(
                name=&quot;velocity&quot;,
                value=self.simulation_state.velocity,
                item_type=&quot;iterable&quot;,
            )

        self.log_plasma_state(
            self.simulation_state.t_radiative,
            self.simulation_state.dilution_factor,
            self.simulation_state.t_inner,
            next_t_radiative,
            next_dilution_factor,
            next_t_inner,
        )
        self.simulation_state.t_radiative = next_t_radiative
        self.simulation_state.dilution_factor = next_dilution_factor
        self.simulation_state.blackbody_packet_source.temperature = next_t_inner

        radiation_field = DilutePlanckianRadiationField(
            temperature=self.simulation_state.t_radiative,
            dilution_factor=self.simulation_state.dilution_factor,
        )
        update_properties = dict(
            dilute_planckian_radiation_field=radiation_field
        )

        # model.calculate_j_blues() equivalent
        # model.update_plasmas() equivalent
        # Bad test to see if this is a nlte run

        if &quot;nlte_data&quot; in self.plasma.outputs_dict:
            self.plasma.store_previous_properties()

        # JBlues solver
        if (
            self.plasma.plasma_solver_settings.RADIATIVE_RATES_TYPE
            == &quot;blackbody&quot;
        ):
            planckian_radiation_field = (
                radiation_field.to_planckian_radiation_field()
            )
            j_blues = planckian_radiation_field.calculate_mean_intensity(
                self.plasma.atomic_data.lines.nu.values
            )
            update_properties[&quot;j_blues&quot;] = pd.DataFrame(
                j_blues, index=self.plasma.atomic_data.lines.index
            )
        elif (
            self.plasma.plasma_solver_settings.RADIATIVE_RATES_TYPE
            == &quot;dilute-blackbody&quot;
        ):
            j_blues = radiation_field.calculate_mean_intensity(
                self.plasma.atomic_data.lines.nu.values
            )
            update_properties[&quot;j_blues&quot;] = pd.DataFrame(
                j_blues, index=self.plasma.atomic_data.lines.index
            )
        elif (
            self.plasma.plasma_solver_settings.RADIATIVE_RATES_TYPE
            == &quot;detailed&quot;
        ):
            update_properties[&quot;j_blues&quot;] = pd.DataFrame(
                estimated_radfield_properties.j_blues,
                index=self.plasma.atomic_data.lines.index,
            )
        else:
            raise ValueError(
                f&quot;radiative_rates_type type unknown - {self.plasma.plasma_solver_settings.RADIATIVE_RATES_TYPE}&quot;
            )

        # A check to see if the plasma is set with JBluesDetailed, in which
        # case it needs some extra kwargs.

        radfield_mc_estimators = (
            self.transport.transport_state.radfield_mc_estimators
        )

        if &quot;gamma&quot; in self.plasma.outputs_dict:
            continuum_property_solver = MCContinuumPropertiesSolver(
                self.plasma.atomic_data
            )
            estimated_continuum_properties = continuum_property_solver.solve(
                radfield_mc_estimators,
                self.transport.transport_state.time_of_simulation,
                self.transport.transport_state.geometry_state.volume,
            )
            update_properties.update(
                gamma=estimated_continuum_properties.photo_ionization_rate_coefficient,
                alpha_stim_factor=estimated_continuum_properties.stimulated_recombination_rate_factor,
                bf_heating_coeff_estimator=radfield_mc_estimators.bf_heating_estimator,
                stim_recomb_cooling_coeff_estimator=radfield_mc_estimators.stim_recomb_cooling_estimator,
            )

        self.plasma.update(**update_properties)

        return converged</div>


<div class="viewcode-block" id="Simulation.iterate">
<a class="viewcode-back" href="../../../api/tardis.simulation.base.html#tardis.simulation.base.Simulation.iterate">[docs]</a>
    def iterate(self, no_of_packets, no_of_virtual_packets=0):
        logger.info(
            f&quot;\n\tStarting iteration {(self.iterations_executed + 1):d} of {self.iterations:d}&quot;
        )

        if self.macro_atom is None:
            self.plasma.beta_sobolev = None
            self.macro_atom_state = None

        self.opacity_state = self.opacity.legacy_solve(self.plasma)
        if self.macro_atom is not None:
            if montecarlo_globals.CONTINUUM_PROCESSES_ENABLED:
                self.macro_atom_state = LegacyMacroAtomState.from_legacy_plasma(
                    self.plasma
                )  # TODO: Impliment
            else:
                self.macro_atom_state = self.macro_atom.solve(
                    self.plasma.j_blues,
                    self.opacity_state.beta_sobolev,
                    self.plasma.stimulated_emission_factor,
                )

        transport_state = self.transport.initialize_transport_state(
            self.simulation_state,
            self.opacity_state,
            self.macro_atom_state,
            self.plasma,
            no_of_packets,
            no_of_virtual_packets=no_of_virtual_packets,
            iteration=self.iterations_executed,
        )

        v_packets_energy_hist = self.transport.run(
            transport_state,
            show_progress_bars=self.show_progress_bars,
        )

        output_energy = (
            self.transport.transport_state.packet_collection.output_energies
        )
        if np.sum(output_energy &lt; 0) == len(output_energy):
            logger.critical(&quot;No r-packet escaped through the outer boundary.&quot;)

        emitted_luminosity = calculate_filtered_luminosity(
            transport_state.emitted_packet_nu,
            transport_state.emitted_packet_luminosity,
            self.luminosity_nu_start,
            self.luminosity_nu_end,
        )
        reabsorbed_luminosity = calculate_filtered_luminosity(
            transport_state.reabsorbed_packet_nu,
            transport_state.reabsorbed_packet_luminosity,
            self.luminosity_nu_start,
            self.luminosity_nu_end,
        )
        self.emitted_luminosity = emitted_luminosity
        self.reabsorbed_luminosity = reabsorbed_luminosity
        if hasattr(self, &quot;convergence_plots&quot;):
            self.convergence_plots.fetch_data(
                name=&quot;Emitted&quot;,
                value=emitted_luminosity.value,
                item_type=&quot;value&quot;,
            )
            self.convergence_plots.fetch_data(
                name=&quot;Absorbed&quot;,
                value=reabsorbed_luminosity.value,
                item_type=&quot;value&quot;,
            )
            self.convergence_plots.fetch_data(
                name=&quot;Requested&quot;,
                value=self.luminosity_requested.value,
                item_type=&quot;value&quot;,
            )

        self.log_run_results(emitted_luminosity, reabsorbed_luminosity)
        self.iterations_executed += 1
        return emitted_luminosity, v_packets_energy_hist</div>


<div class="viewcode-block" id="Simulation.run_convergence">
<a class="viewcode-back" href="../../../api/tardis.simulation.base.html#tardis.simulation.base.Simulation.run_convergence">[docs]</a>
    def run_convergence(self):
        &quot;&quot;&quot;
        run the simulation
        &quot;&quot;&quot;
        # Initialize iterations progress bar if showing progress bars
        if self.show_progress_bars:
            initialize_iterations_pbar(self.iterations)

        start_time = time.time()
        while self.iterations_executed &lt; self.iterations - 1:
            self.store_plasma_state(
                self.iterations_executed,
                self.simulation_state.dilution_factor,
                self.simulation_state.t_radiative,
                self.plasma.electron_densities,
                self.simulation_state.t_inner,
            )
            emitted_luminosity, v_packets_energy_hist = self.iterate(
                self.no_of_packets
            )
            self.converged = self.advance_state(emitted_luminosity)
            if hasattr(self, &quot;convergence_plots&quot;):
                self.convergence_plots.update()
            self._call_back()
            if self.converged:
                if self.convergence_strategy.stop_if_converged:
                    break

        logger.info(
            f&quot;\n\tSimulation finished in {self.iterations_executed:d} iterations &quot;
            f&quot;\n\tSimulation took {(time.time() - start_time):.2f} s\n&quot;
        )</div>


<div class="viewcode-block" id="Simulation.run_final">
<a class="viewcode-back" href="../../../api/tardis.simulation.base.html#tardis.simulation.base.Simulation.run_final">[docs]</a>
    def run_final(self):
        &quot;&quot;&quot;
        run the last iteration of the simulation
        &quot;&quot;&quot;
        self.store_plasma_state(
            self.iterations_executed,
            self.simulation_state.dilution_factor,
            self.simulation_state.t_radiative,
            self.plasma.electron_densities,
            self.simulation_state.t_inner,
        )

        # Set up spectrum solver integrator and virtual spectrum
        emitted_luminosity, v_packets_energy_hist = self.iterate(
            self.last_no_of_packets, self.no_of_virtual_packets
        )

        integrator_settings = self.spectrum_solver.integrator_settings
        formal_integral_solver = FormalIntegralSolver(
            integrator_settings.points,
            integrator_settings.interpolate_shells,
            getattr(integrator_settings, &quot;method&quot;, None),
        )

        self.spectrum_solver.setup_optional_spectra(
            self.transport.transport_state,
            v_packets_energy_hist,
            formal_integral_solver,
            self.simulation_state,
            self.transport,
            self.plasma,
            opacity_state=self.opacity_state,
            macro_atom_state=self.macro_atom_state,
        )

        self.reshape_plasma_state_store(self.iterations_executed)
        if hasattr(self, &quot;convergence_plots&quot;):
            self.convergence_plots.fetch_data(
                name=&quot;t_inner&quot;,
                value=self.simulation_state.t_inner.value,
                item_type=&quot;value&quot;,
            )
            self.convergence_plots.update(
                export_convergence_plots=self.export_convergence_plots,
                last=True,
            )

        self._call_back()</div>


<div class="viewcode-block" id="Simulation.log_plasma_state">
<a class="viewcode-back" href="../../../api/tardis.simulation.base.html#tardis.simulation.base.Simulation.log_plasma_state">[docs]</a>
    def log_plasma_state(
        self,
        t_rad,
        dilution_factor,
        t_inner,
        next_t_rad,
        next_dilution_factor,
        next_t_inner,
        log_sampling=5,
    ):
        &quot;&quot;&quot;
        Logging the change of the plasma state

        Parameters
        ----------
        t_rad : astropy.units.Quanity
            current t_rad
        dilution_factor : np.ndarray
            current dilution_factor
        next_t_rad : astropy.units.Quanity
            next t_rad
        next_dilution_factor : np.ndarray
            next dilution_factor
        log_sampling : int
            the n-th shells to be plotted

        Returns
        -------
        &quot;&quot;&quot;
        plasma_state_log = pd.DataFrame(
            index=np.arange(len(t_rad)),
            columns=[&quot;t_rad&quot;, &quot;next_t_rad&quot;, &quot;w&quot;, &quot;next_w&quot;],
        )
        plasma_state_log[&quot;t_rad&quot;] = t_rad.value
        plasma_state_log[&quot;next_t_rad&quot;] = next_t_rad.value
        plasma_state_log[&quot;w&quot;] = dilution_factor
        plasma_state_log[&quot;next_w&quot;] = next_dilution_factor
        plasma_state_log.columns.name = &quot;Shell No.&quot;
        logger.info(plasma_state_log.iloc[::log_sampling])
        logger.info(
            f&quot;\n\tCurrent t_inner = {t_inner:.3f}\n\tExpected t_inner for next iteration = {next_t_inner:.3f}\n&quot;
        )</div>


<div class="viewcode-block" id="Simulation.log_run_results">
<a class="viewcode-back" href="../../../api/tardis.simulation.base.html#tardis.simulation.base.Simulation.log_run_results">[docs]</a>
    def log_run_results(self, emitted_luminosity, absorbed_luminosity):
        logger.info(
            f&quot;\n\tLuminosity emitted   = {emitted_luminosity:.3e}\n&quot;
            f&quot;\tLuminosity absorbed  = {absorbed_luminosity:.3e}\n&quot;
            f&quot;\tLuminosity requested = {self.luminosity_requested:.3e}\n&quot;
        )</div>


    def _call_back(self):
        for cb, args in self._callbacks.values():
            cb(self, *args)

<div class="viewcode-block" id="Simulation.add_callback">
<a class="viewcode-back" href="../../../api/tardis.simulation.base.html#tardis.simulation.base.Simulation.add_callback">[docs]</a>
    def add_callback(self, cb_func, *args):
        &quot;&quot;&quot;
        Add a function which will be called
        after every iteration.

        The cb_func signature must look like:
        cb_func(simulation, extra_arg1, ...)

        Parameters
        ----------
        cb_func : callable
            The callback function
        arg1 :
            The first additional arguments passed to the callable function
        ...

        Returns
        -------
        : int
            The callback ID
        &quot;&quot;&quot;
        cb_id = self._cb_next_id
        self._callbacks[cb_id] = (cb_func, args)
        self._cb_next_id += 1
        return cb_id</div>


<div class="viewcode-block" id="Simulation.remove_callback">
<a class="viewcode-back" href="../../../api/tardis.simulation.base.html#tardis.simulation.base.Simulation.remove_callback">[docs]</a>
    def remove_callback(self, id):
        &quot;&quot;&quot;
        Remove the callback with a specific ID (which was returned by
        add_callback)

        Parameters
        ----------
        id : int
            The callback ID

        Returns
        -------
        : True if the callback was successfully removed.
        &quot;&quot;&quot;
        try:
            del self._callbacks[id]
            return True
        except KeyError:
            logger.debug(f&quot;Call Back was not found in {self._callbacks.keys()}&quot;)
            return False</div>


<div class="viewcode-block" id="Simulation.from_config">
<a class="viewcode-back" href="../../../api/tardis.simulation.base.html#tardis.simulation.base.Simulation.from_config">[docs]</a>
    @classmethod
    def from_config(
        cls,
        config,
        packet_source=None,
        virtual_packet_logging=False,
        show_convergence_plots=False,
        show_progress_bars=True,
        legacy_mode_enabled=False,
        atom_data=None,
        plasma=None,
        transport=None,
        opacity=None,
        macro_atom=None,
        **kwargs,
    ):
        &quot;&quot;&quot;
        Create a simulation instance from the provided configuration.

        Parameters
        ----------
        config : object
            The configuration object for the simulation.
        packet_source : object, optional
            The packet source for the simulation.
        virtual_packet_logging : bool, optional
            Flag indicating virtual packet logging.
        show_convergence_plots : bool, optional
            Flag indicating whether to show convergence plots.
        show_progress_bars : bool, optional
            Flag indicating whether to show progress bars.
        legacy_mode_enabled : bool, optional
            Flag indicating if legacy mode is enabled.
        atom_data : object, optional
            The atom data for the simulation.
        plasma : object, optional
            The plasma object for the simulation.
        transport : object, optional
            The transport solver for the simulation.
        **kwargs
            Additional keyword arguments.

        Returns
        -------
        object
            The created simulation instance.
        &quot;&quot;&quot;
        # Allow overriding some config structures. This is useful in some
        # unit tests, and could be extended in all the from_config classmethods.

        atom_data = parse_atom_data(config, atom_data=atom_data)
        simulation_state = parse_simulation_state(
            config, packet_source, legacy_mode_enabled, kwargs, atom_data
        )
        if plasma is None:
            plasma = assemble_plasma(
                config,
                simulation_state,
                atom_data=atom_data,
            )

        if (transport is not None) and (packet_source is not None):
            raise ConfigurationError(
                &quot;Cannot specify packet_source and transport at the same time.&quot;
            )
        if transport is None:
            transport = MonteCarloTransportSolver.from_config(
                config,
                packet_source=simulation_state.packet_source,
                enable_virtual_packet_logging=virtual_packet_logging,
            )
        if opacity is None:
            opacity = OpacitySolver(
                config.plasma.line_interaction_type,
                config.plasma.disable_line_scattering,
            )
        if macro_atom is None:
            if config.plasma.line_interaction_type in (
                &quot;downbranch&quot;,
                &quot;macroatom&quot;,
            ):
                macro_atom = BoundBoundMacroAtomSolver(
                    atom_data.levels,
                    atom_data.lines,
                    line_interaction_type=config.plasma.line_interaction_type,
                )

        convergence_plots_config_options = [
            &quot;plasma_plot_config&quot;,
            &quot;t_inner_luminosities_config&quot;,
            &quot;plasma_cmap&quot;,
            &quot;t_inner_luminosities_colors&quot;,
            &quot;export_convergence_plots&quot;,
        ]
        convergence_plots_kwargs = {}
        for item in set(convergence_plots_config_options).intersection(
            kwargs.keys()
        ):
            convergence_plots_kwargs[item] = kwargs[item]

        luminosity_nu_start = config.supernova.luminosity_wavelength_end.to(
            u.Hz, u.spectral()
        )

        if u.isclose(
            config.supernova.luminosity_wavelength_start, 0 * u.angstrom
        ):
            luminosity_nu_end = np.inf * u.Hz
        else:
            luminosity_nu_end = (
                const.c / config.supernova.luminosity_wavelength_start
            ).to(u.Hz)

        last_no_of_packets = config.montecarlo.last_no_of_packets
        if last_no_of_packets is None or last_no_of_packets &lt; 0:
            last_no_of_packets = config.montecarlo.no_of_packets
        last_no_of_packets = int(last_no_of_packets)

        spectrum_solver = SpectrumSolver.from_config(config)

        return cls(
            iterations=config.montecarlo.iterations,
            simulation_state=simulation_state,
            plasma=plasma,
            transport=transport,
            opacity=opacity,
            macro_atom=macro_atom,
            show_convergence_plots=show_convergence_plots,
            no_of_packets=int(config.montecarlo.no_of_packets),
            no_of_virtual_packets=int(config.montecarlo.no_of_virtual_packets),
            luminosity_nu_start=luminosity_nu_start,
            luminosity_nu_end=luminosity_nu_end,
            last_no_of_packets=last_no_of_packets,
            luminosity_requested=config.supernova.luminosity_requested.cgs,
            convergence_strategy=config.montecarlo.convergence_strategy,
            convergence_plots_kwargs=convergence_plots_kwargs,
            show_progress_bars=show_progress_bars,
            spectrum_solver=spectrum_solver,
        )</div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2013-2025, TARDIS Collaboration.
      <span class="lastupdated">Last updated on 12 Oct 2025.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>