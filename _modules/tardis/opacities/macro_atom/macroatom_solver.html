

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-53HJHD1BWS"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-53HJHD1BWS');
    </script>
    
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>tardis.opacities.macro_atom.macroatom_solver &mdash; tardis</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />

  
    <link rel="shortcut icon" href="../../../../_static/tardis_logo.ico"/>
      <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../_static/documentation_options.js?v=0c5691da"></script>
      <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@1.0.13/dist/embed-amd.min.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link href="../../../../_static/tardis.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            tardis
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../getting_started/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../quickstart.html">Quickstart for TARDIS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../resources/credits.html">Credits &amp; Publication Policies</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/high_energy/run_high_energy_workflow.html">TARDIS High Energy Workflow Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../analyzing_tardis/visualization/tutorial_montecarlo_packet_visualization.html">Montecarlo Packet Visualization</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">How-to Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../how_to_guides.html">How-To Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../workflows.html">Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../analyzing_tardis/index.html">Analyszing TARDIS Simulation Outputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../io/configuration/tutorial_read_configuration.html">Reading a Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../io/optional/index.html">Optional Inputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../io/output/index.html">Additional Outputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../how-to/code_comparison/index.html">How to do Code Comparison using TARDIS</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Physics Walkthrough</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../physics_walkthrough/intro/index.html">Physics Walkthrough Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../physics_walkthrough/setup/index.html">Setting Up the Simulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../physics_walkthrough/montecarlo/index.html">Monte Carlo Iteration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../physics_walkthrough/update_and_conv/update_and_conv.html">Updating Plasma and Convergence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../physics_walkthrough/spectrum/index.html">Spectrum Generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../physics_walkthrough/tardisgamma/index.html">TARDIS-High Energy</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/modules.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../reference/faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../reference/visualization_reference.html">Visualization Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../io/configuration/index.html">Configuration Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../io/hdf/index.html">Hierarchical Data Format (HDF5) Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contributing/CHANGELOG.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../resources/research_done_using_TARDIS/research_papers.html">Papers Using TARDIS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../resources/zreferences.html">Bibliography and Glossary</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contributing to TARDIS</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../contributing/CONTRIBUTING.html">Contribution Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contributing/development/index.html">Developer Workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contributing/tools/index.html">Developer Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contributing/in_progress/index.html">Features In-Progress</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">tardis</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">tardis.opacities.macro_atom.macroatom_solver</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for tardis.opacities.macro_atom.macroatom_solver</h1><div class="highlight"><pre>
<span></span>import numpy as np
import pandas as pd

from tardis.configuration.sorting_globals import SORTING_ALGORITHM
from tardis.io.atom_data import AtomData
from tardis.opacities.macro_atom import util
from tardis.opacities.macro_atom.base import (
    get_macro_atom_data,
    initialize_transition_probabilities,
)
from tardis.opacities.macro_atom.macroatom_state import (
    LegacyMacroAtomState,
    MacroAtomState,
)
from tardis.opacities.macro_atom.macroatom_transitions import (
    line_transition_emission_down,
    line_transition_internal_down,
    line_transition_internal_up,
    probability_emission_down,
    probability_internal_down,
    probability_internal_up,
)
from tardis.transport.montecarlo.macro_atom import MacroAtomTransitionType


<div class="viewcode-block" id="LegacyMacroAtomSolver">
<a class="viewcode-back" href="../../../../api/tardis.opacities.macro_atom.macroatom_solver.html#tardis.opacities.macro_atom.macroatom_solver.LegacyMacroAtomSolver">[docs]</a>
class LegacyMacroAtomSolver:
    initialize: bool = True
    normalize: bool = True

    def __init__(self, initialize: bool = True, normalize: bool = True) -&gt; None:
        &quot;&quot;&quot;
        Initialize the LegacyMacroAtomSolver.

        Parameters
        ----------
        initialize : bool, optional
            Whether or not to initialize the transition probability coefficients and block references when solving the first time. Default is True.
        normalize : bool, optional
            Whether or not to normalize the transition probabilities to unity. Default is True.
        &quot;&quot;&quot;
        self.initialize = initialize
        self.normalize = normalize

<div class="viewcode-block" id="LegacyMacroAtomSolver.initialize_transition_probabilities">
<a class="viewcode-back" href="../../../../api/tardis.opacities.macro_atom.macroatom_solver.html#tardis.opacities.macro_atom.macroatom_solver.LegacyMacroAtomSolver.initialize_transition_probabilities">[docs]</a>
    def initialize_transition_probabilities(
        self, atomic_data: AtomData
    ) -&gt; None:
        &quot;&quot;&quot;
        Initialize the transition probability coefficients and block references.

        This method should be called when solving for the first time to set up
        the necessary coefficients and block references.

        Parameters
        ----------
        atomic_data : AtomData
            Atomic data containing the necessary information for initialization.
        &quot;&quot;&quot;
        coef_and_block_ref = initialize_transition_probabilities(atomic_data)
        self.transition_probability_coef = coef_and_block_ref[
            &quot;transition_probability_coef&quot;
        ]
        self.block_references = coef_and_block_ref[&quot;block_references&quot;]
        self.initialize = False</div>


<div class="viewcode-block" id="LegacyMacroAtomSolver.solve_transition_probabilities">
<a class="viewcode-back" href="../../../../api/tardis.opacities.macro_atom.macroatom_solver.html#tardis.opacities.macro_atom.macroatom_solver.LegacyMacroAtomSolver.solve_transition_probabilities">[docs]</a>
    def solve_transition_probabilities(
        self,
        atomic_data: AtomData,
        mean_intensities_lines_blue_wing: pd.DataFrame,
        tau_sobolev: pd.DataFrame,
        beta_sobolev: pd.DataFrame | None,
        stimulated_emission_factor: pd.DataFrame | np.ndarray,
    ) -&gt; pd.DataFrame | None:
        &quot;&quot;&quot;
        Solve the basic transition probabilities for the macroatom.

        Parameters
        ----------
        atomic_data : AtomData
            Atomic data containing macro atom information.
        mean_intensities_lines_blue_wing : pd.DataFrame
            Mean intensity of the radiation field of each line in the blue wing for each shell.
            For more detail see Lucy 2003, https://doi.org/10.1051/0004-6361:20030357
        tau_sobolev : pd.DataFrame
            Expansion optical depths.
        beta_sobolev : pd.DataFrame | None
            Modified expansion optical depths.
        stimulated_emission_factor : pd.DataFrame | np.ndarray
            Stimulated emission factors.

        Returns
        -------
        pd.DataFrame | None
            Transition probabilities. Returns None if mean_intensities_lines_blue_wing is empty.
        &quot;&quot;&quot;
        if self.initialize:
            self.initialize_transition_probabilities(atomic_data)
        # Referenced in https://github.com/tardis-sn/tardis/issues/3009
        if len(mean_intensities_lines_blue_wing) == 0:
            return None
        macro_atom_data = get_macro_atom_data(atomic_data)

        transition_probabilities = np.empty(
            (self.transition_probability_coef.shape[0], beta_sobolev.shape[1])
        )
        transition_type = macro_atom_data.transition_type.values
        lines_idx = macro_atom_data.lines_idx.values
        tpos = macro_atom_data.transition_probability.values
        # This function modifies transition_probabilities inplace
        util.fast_calculate_transition_probabilities(
            tpos,
            beta_sobolev.values,
            mean_intensities_lines_blue_wing.values,
            stimulated_emission_factor,
            transition_type,
            lines_idx,
            self.block_references,
            transition_probabilities,
            self.normalize,
        )
        transition_probabilities_df = pd.DataFrame(
            transition_probabilities,
            index=macro_atom_data.transition_line_id,
            columns=tau_sobolev.columns,
        )

        return transition_probabilities_df</div>


<div class="viewcode-block" id="LegacyMacroAtomSolver.solve">
<a class="viewcode-back" href="../../../../api/tardis.opacities.macro_atom.macroatom_solver.html#tardis.opacities.macro_atom.macroatom_solver.LegacyMacroAtomSolver.solve">[docs]</a>
    def solve(
        self,
        mean_intensities_lines_blue_wing: pd.DataFrame,
        atomic_data: AtomData,
        tau_sobolev: pd.DataFrame,
        stimulated_emission_factor: pd.DataFrame,
        beta_sobolev: pd.DataFrame | None = None,
    ) -&gt; LegacyMacroAtomState:
        &quot;&quot;&quot;
        Solve the Macro Atom State.

        Parameters
        ----------
        mean_intensities_lines_blue_wing : pd.DataFrame
            Mean intensity of the radiation field of each line in the blue wing for each shell.
        atomic_data : AtomData
            Atomic data containing macro atom information.
        tau_sobolev : pd.DataFrame
            Expansion optical depths.
        stimulated_emission_factor : pd.DataFrame
            Stimulated emission factors.
        beta_sobolev : pd.DataFrame | None, optional
            Modified expansion optical depths. Default is None.

        Returns
        -------
        LegacyMacroAtomState
            State of the macro atom ready to be placed into the OpacityState.
        &quot;&quot;&quot;
        transition_probabilities = self.solve_transition_probabilities(
            atomic_data,
            mean_intensities_lines_blue_wing,
            tau_sobolev,
            beta_sobolev,
            stimulated_emission_factor,
        )

        macro_block_references = atomic_data.macro_atom_references[
            &quot;block_references&quot;
        ]
        macro_atom_info = atomic_data.macro_atom_data

        return LegacyMacroAtomState(
            transition_probabilities,
            macro_atom_info[&quot;transition_type&quot;],
            macro_atom_info[&quot;destination_level_idx&quot;],
            macro_atom_info[&quot;lines_idx&quot;],
            macro_block_references,
            atomic_data.lines_upper2macro_reference_idx,
        )</div>
</div>



<div class="viewcode-block" id="BoundBoundMacroAtomSolver">
<a class="viewcode-back" href="../../../../api/tardis.opacities.macro_atom.macroatom_solver.html#tardis.opacities.macro_atom.macroatom_solver.BoundBoundMacroAtomSolver">[docs]</a>
class BoundBoundMacroAtomSolver:
    levels: pd.DataFrame
    lines: pd.DataFrame

    def __init__(
        self,
        levels: pd.DataFrame,
        lines: pd.DataFrame,
        line_interaction_type: str = &quot;macroatom&quot;,
    ) -&gt; None:
        &quot;&quot;&quot;
        Initialize the BoundBoundMacroAtomSolver.

        Parameters
        ----------
        levels : pd.DataFrame
            DataFrame containing atomic level information.
        lines : pd.DataFrame
            DataFrame containing spectral line information.
        line_interaction_type : str, optional
            Type of line interaction to use. Default is &quot;macroatom&quot;.
        &quot;&quot;&quot;
        self.levels = levels
        self.lines = lines
        self.line_interaction_type = line_interaction_type

        self._precompute_static_data()

    def _precompute_static_data(self):
        self._oscillator_strength_ul = self.lines.f_ul.to_numpy().reshape(-1, 1)
        self._oscillator_strength_lu = self.lines.f_lu.to_numpy().reshape(-1, 1)
        self._nus = self.lines.nu.to_numpy().reshape(-1, 1)
        self._energies_upper = (
            self.levels[[&quot;energy&quot;]]
            .reindex(self.lines.index.droplevel(&quot;level_number_lower&quot;))
            .to_numpy()
        )
        self._energies_lower = (
            self.levels[[&quot;energy&quot;]]
            .reindex(self.lines.index.droplevel(&quot;level_number_upper&quot;))
            .to_numpy()
        )
        self._transition_a_i_l_u_array = self.lines.reset_index()[
            [
                &quot;atomic_number&quot;,
                &quot;ion_number&quot;,
                &quot;level_number_lower&quot;,
                &quot;level_number_upper&quot;,
            ]
        ].to_numpy()  # This is a helper array to make the source and destination columns. The letters stand for atomic_number, ion_number, lower level, upper level.

        self._lines_level_upper = self.lines.index.droplevel(
            &quot;level_number_lower&quot;
        )

<div class="viewcode-block" id="BoundBoundMacroAtomSolver.solve">
<a class="viewcode-back" href="../../../../api/tardis.opacities.macro_atom.macroatom_solver.html#tardis.opacities.macro_atom.macroatom_solver.BoundBoundMacroAtomSolver.solve">[docs]</a>
    def solve(
        self,
        mean_intensities_blue_wing: pd.DataFrame,
        beta_sobolevs: pd.DataFrame,
        stimulated_emission_factors: np.ndarray,
    ) -&gt; MacroAtomState:
        &quot;&quot;&quot;
        Solve the transition probabilities for the macroatom.

        This method calculates transition probabilities and returns a MacroAtomState object
        with the probabilities and macro atom transition metadata.
        Referenced as $p_i$ in Lucy 2003, https://doi.org/10.1051/0004-6361:20030357

        Parameters
        ----------
        mean_intensities_blue_wing : pd.DataFrame
            Mean intensity of the radiation field of each line in the blue wing for each shell.
            For more detail see Lucy 2003, https://doi.org/10.1051/0004-6361:20030357
            Referenced as &#39;J^b_{lu}&#39; internally, or &#39;J^b_{ji}&#39; in the original paper.
        beta_sobolevs : pd.DataFrame
            Escape probabilities for the Sobolev approximation.
        stimulated_emission_factors : np.ndarray
            Stimulated emission factors for the lines.

        Returns
        -------
        MacroAtomState
            A MacroAtomState object containing the transition probabilities, transition metadata,
            and a mapping from line IDs to macro atom level upper indices.
        &quot;&quot;&quot;
        is_first_iteration = not hasattr(self, &quot;computed_metadata&quot;)

        if is_first_iteration:
            (
                normalized_probabilities,
                macro_atom_transition_metadata,
                line2macro_level_upper,
                macro_block_references,
                references_index,
            ) = self._solve_first_macroatom_iteration(
                mean_intensities_blue_wing,
                beta_sobolevs,
                stimulated_emission_factors,
                self._lines_level_upper,
            )
        else:
            normalized_probabilities = self._solve_next_macroatom_iteration(
                mean_intensities_blue_wing,
                beta_sobolevs,
                stimulated_emission_factors,
            )
            (
                macro_atom_transition_metadata,
                line2macro_level_upper,
                macro_block_references,
                references_index,
            ) = self.computed_metadata

        return MacroAtomState(
            normalized_probabilities,
            macro_atom_transition_metadata,
            line2macro_level_upper,
            macro_block_references,
            references_index,
        )</div>


    def _solve_first_macroatom_iteration(
        self,
        mean_intensities_blue_wing: pd.DataFrame,
        beta_sobolevs: pd.DataFrame,
        stimulated_emission_factors: np.ndarray,
        lines_level_upper: pd.MultiIndex,
    ) -&gt; tuple[pd.DataFrame, pd.DataFrame, pd.Series, pd.Series, pd.Series]:
        &quot;&quot;&quot;
        Handle the first iteration of the solve method.

        Fully computes all metadata for the macroatom and adds it to the class with
        the computed_metadata attribute. This method performs the complete calculation
        including transition probability computation, normalization, sorting, and
        metadata preparation.

        Parameters
        ----------
        mean_intensities_blue_wing : pd.DataFrame
            Mean intensity of the radiation field of each line in the blue wing for each shell.
            For more detail see Lucy 2003, https://doi.org/10.1051/0004-6361:20030357.
            Referenced as &#39;J^b_{lu}&#39; internally, or &#39;J^b_{ji}&#39; in the original paper.
        beta_sobolevs : pd.DataFrame
            Escape probabilities for the Sobolev approximation. These probabilities
            represent the fraction of photons that escape the line formation region
            without being reabsorbed.
        stimulated_emission_factors : np.ndarray
            Factors accounting for stimulated emission in the transitions. These
            modify the transition probabilities based on the radiation field strength.
        lines_level_upper : pd.MultiIndex
            MultiIndex containing the upper level information for each line transition,
            used for creating the line-to-macro-atom level mapping.

        Returns
        -------
        normalized_probabilities : pd.DataFrame
            DataFrame containing normalized transition probabilities where each source
            group sums to 1.0.
        macro_atom_transition_metadata : pd.DataFrame
            DataFrame containing metadata for transitions including source and
            destination levels, transition types, and line indices.
        line2macro_level_upper : pd.Series
            Series mapping line transitions to macro atom level indices for upper levels.
        macro_block_references : pd.Series
            Series with unique source levels as index and their first occurrence
            index in the metadata as values.
        &quot;&quot;&quot;
        if self.line_interaction_type in [&quot;downbranch&quot;, &quot;macroatom&quot;]:
            p_emission_down, emission_down_metadata = (
                line_transition_emission_down(
                    self._oscillator_strength_ul,
                    self._nus,
                    self._energies_upper,
                    self._energies_lower,
                    beta_sobolevs,
                    self._transition_a_i_l_u_array,
                    self.lines.line_id.to_numpy(),
                )
            )
        else:
            raise ValueError(
                f&quot;Unknown line interaction type: {self.line_interaction_type}&quot;
            )
        if self.line_interaction_type == &quot;downbranch&quot;:
            probabilities_df = p_emission_down
            macro_atom_transition_metadata = emission_down_metadata

        elif self.line_interaction_type == &quot;macroatom&quot;:
            p_internal_down, internal_down_metadata = (
                line_transition_internal_down(
                    self._oscillator_strength_ul,
                    self._nus,
                    self._energies_lower,
                    beta_sobolevs,
                    self._transition_a_i_l_u_array,
                    self.lines.line_id.to_numpy(),
                )
            )

            p_internal_up, internal_up_metadata = line_transition_internal_up(
                self._oscillator_strength_lu,
                self._nus,
                self._energies_lower,
                mean_intensities_blue_wing,
                beta_sobolevs,
                stimulated_emission_factors,
                self._transition_a_i_l_u_array,
                self.lines.line_id.to_numpy(),
            )
            probabilities_df = pd.concat(
                [p_emission_down, p_internal_down, p_internal_up]
            )
            macro_atom_transition_metadata = pd.concat(
                [
                    emission_down_metadata,
                    internal_down_metadata,
                    internal_up_metadata,
                ]
            )

        # Normalize the probabilities by source. This used to be optional but is never not done in TARDIS. This also removes the source column from the probabilities DataFrame.
        normalized_probabilities = normalize_transition_probabilities(
            probabilities_df
        )

        normalized_probabilities, macro_atom_transition_metadata = (
            reindex_sort_and_clean_probabilities_and_metadata(
                normalized_probabilities, macro_atom_transition_metadata
            )
        )

        # We have to create the line2macro object after sorting.
        line2macro_level_upper, reference_index = (
            create_line2macro_level_upper_and_reference_idx(
                macro_atom_transition_metadata, lines_level_upper
            )
        )

        macro_atom_transition_metadata.drop(
            columns=[
                &quot;atomic_number&quot;,
                &quot;ion_number&quot;,
                &quot;level_number_lower&quot;,
                &quot;level_number_upper&quot;,
                &quot;source_level&quot;,
            ],
            inplace=True,
        )
        source_to_index = {
            source: idx
            for idx, source in enumerate(
                macro_atom_transition_metadata.source.unique()
            )
        }
        # -99 should never be used downstream. The presence of it means the destination is not a source,
        # which means that the destination is only referenced from emission
        # (or macroatom deactivation) for the given macroatom configuration.
        macro_atom_transition_metadata[&quot;destination_level_idx&quot;] = (
            (macro_atom_transition_metadata.destination.map(source_to_index))
            .fillna(-99)
            .astype(np.int64)
        )

        macro_atom_transition_metadata[&quot;source_level_idx&quot;] = (
            macro_atom_transition_metadata.source.map(source_to_index)
        ).astype(np.int64)

        macro_block_references = create_macro_block_references(
            macro_atom_transition_metadata
        )

        self.computed_metadata = (
            macro_atom_transition_metadata,
            line2macro_level_upper,
            macro_block_references,
            reference_index,
        )

        return (
            normalized_probabilities,
            macro_atom_transition_metadata,
            line2macro_level_upper,
            macro_block_references,
            reference_index,
        )

    def _solve_next_macroatom_iteration(
        self,
        mean_intensities_blue_wing: pd.DataFrame,
        beta_sobolevs: pd.DataFrame,
        stimulated_emission_factors: np.ndarray,
    ) -&gt; pd.DataFrame:
        &quot;&quot;&quot;
        Handle subsequent iterations of the solve method.

        Uses precomputed metadata and only recalculates the probabilities. This method
        is optimized for speed by reusing the transition metadata, block references,
        and line mappings computed in the first iteration.

        Parameters
        ----------
        mean_intensities_blue_wing : pd.DataFrame
            Mean intensity of the radiation field of each line in the blue wing for each shell.
            For more detail see Lucy 2003, https://doi.org/10.1051/0004-6361:20030357.
            Referenced as &#39;J^b_{lu}&#39; internally, or &#39;J^b_{ji}&#39; in the original paper.
            This parameter may have updated values compared to the first iteration.
        beta_sobolevs : pd.DataFrame
            Escape probabilities for the Sobolev approximation. These probabilities
            represent the fraction of photons that escape the line formation region
            without being reabsorbed. Values may be updated from the first iteration.
        stimulated_emission_factors : np.ndarray
            Factors accounting for stimulated emission in the transitions. These
            modify the transition probabilities based on the radiation field strength.
            May contain updated values from the radiation field calculation.

        Returns
        -------
        pd.DataFrame
            DataFrame containing normalized transition probabilities where each source
            group sums to 1.0. The structure matches the first iteration output but
            with updated probability values.
        &quot;&quot;&quot;
        (
            macro_atom_transition_metadata,
            line2macro_level_upper,
            macro_block_references,
            reference_index,
        ) = self.computed_metadata
        line_trans_internal_up_ids = macro_atom_transition_metadata[
            macro_atom_transition_metadata.transition_type
            == MacroAtomTransitionType.INTERNAL_UP
        ].transition_line_idx.to_numpy()
        line_trans_internal_down_ids = macro_atom_transition_metadata[
            macro_atom_transition_metadata.transition_type
            == MacroAtomTransitionType.INTERNAL_DOWN
        ].transition_line_idx.to_numpy()
        line_trans_emission_down_ids = macro_atom_transition_metadata[
            macro_atom_transition_metadata.transition_type
            == MacroAtomTransitionType.BB_EMISSION
        ].transition_line_idx.to_numpy()

        probabilities_df = pd.DataFrame(
            np.zeros(
                (
                    macro_atom_transition_metadata.shape[0],
                    beta_sobolevs.shape[1],
                )
            ),
            index=macro_atom_transition_metadata.index,
            columns=beta_sobolevs.columns,
        )
        probabilities_df[
            macro_atom_transition_metadata.transition_type
            == MacroAtomTransitionType.BB_EMISSION
        ] = probability_emission_down(
            beta_sobolevs.iloc[line_trans_emission_down_ids],
            self._nus[line_trans_emission_down_ids],
            self._oscillator_strength_ul[line_trans_emission_down_ids],
            self._energies_upper[line_trans_emission_down_ids],
            self._energies_lower[line_trans_emission_down_ids],
        ).to_numpy()
        probabilities_df[
            macro_atom_transition_metadata.transition_type
            == MacroAtomTransitionType.INTERNAL_DOWN
        ] = probability_internal_down(
            beta_sobolevs.iloc[line_trans_internal_down_ids],
            self._nus[line_trans_internal_down_ids],
            self._oscillator_strength_ul[line_trans_internal_down_ids],
            self._energies_lower[line_trans_internal_down_ids],
        ).to_numpy()

        probabilities_df[
            macro_atom_transition_metadata.transition_type
            == MacroAtomTransitionType.INTERNAL_UP
        ] = probability_internal_up(
            beta_sobolevs.iloc[line_trans_internal_up_ids],
            self._nus[line_trans_internal_up_ids],
            self._oscillator_strength_lu[line_trans_internal_up_ids],
            stimulated_emission_factors[line_trans_internal_up_ids],
            mean_intensities_blue_wing.iloc[line_trans_internal_up_ids],
            self._energies_lower[line_trans_internal_up_ids],
        ).to_numpy()

        probabilities_df[&quot;source&quot;] = (
            macro_atom_transition_metadata.source.values
        )
        normalized_probabilities = normalize_transition_probabilities(
            probabilities_df
        )

        return normalized_probabilities</div>



<div class="viewcode-block" id="create_macro_block_references">
<a class="viewcode-back" href="../../../../api/tardis.opacities.macro_atom.macroatom_solver.html#tardis.opacities.macro_atom.macroatom_solver.create_macro_block_references">[docs]</a>
def create_macro_block_references(macro_atom_transition_metadata):
    &quot;&quot;&quot;
    Create macro block references from the macro atom transition metadata.
    This method creates a mapping from unique source levels to their first occurrence index in the metadata.

    Parameters
    ----------
    macro_atom_transition_metadata : pandas.DataFrame
        DataFrame containing metadata for macro atom transitions.

    Returns
    -------
    pandas.Series
        Series with unique source levels as index and their first occurrence index in the metadata as values.
    &quot;&quot;&quot;
    unique_source_multi_index = pd.MultiIndex.from_tuples(
        macro_atom_transition_metadata.source.unique(),
        names=[&quot;atomic_number&quot;, &quot;ion_number&quot;, &quot;level_number&quot;],
    )
    macro_data = (
        macro_atom_transition_metadata.reset_index()
        .groupby(&quot;source&quot;)
        .apply(lambda x: x.index[0])
    )

    # Append a dummy index so that the interactions can access a &quot;block end&quot; if a packet activates the macroatom highest level of the heaviest element in the montecarlo.
    # Without this the kernel will crash trying to access an index that doesn&#39;t exist.
    macro_data = np.append(
        macro_data.values, len(macro_atom_transition_metadata)
    )
    unique_source_multi_index = unique_source_multi_index.append(
        pd.MultiIndex.from_tuples(
            [(-99, -99, -99)],
            names=[&quot;atomic_number&quot;, &quot;ion_number&quot;, &quot;level_number&quot;],
        )
    )

    macro_block_references = pd.Series(
        data=macro_data,
        index=unique_source_multi_index,
        name=&quot;macro_block_references&quot;,
    )

    return macro_block_references</div>



<div class="viewcode-block" id="create_line2macro_level_upper_and_reference_idx">
<a class="viewcode-back" href="../../../../api/tardis.opacities.macro_atom.macroatom_solver.html#tardis.opacities.macro_atom.macroatom_solver.create_line2macro_level_upper_and_reference_idx">[docs]</a>
def create_line2macro_level_upper_and_reference_idx(
    macro_atom_transition_metadata: pd.DataFrame,
    lines_level_upper: pd.MultiIndex,
) -&gt; tuple[pd.Series, pd.Series]:
    &quot;&quot;&quot;
    Create a mapping from line transitions to macro atom level indices for upper levels.
    This method creates a mapping that connects line transition upper levels to their
    corresponding macro atom level indices. It first extracts unique source levels
    from the macro atom transition metadata and assigns sequential indices to them,
    then maps the line upper levels to these indices.

    Parameters
    ----------
    macro_atom_transition_metadata : pd.DataFrame
        DataFrame containing macro atom transition metadata
    lines_level_upper : pd.MultiIndex
        MultiIndex containing line upper level information

    Returns
    -------
    pd.Series
        Series mapping line transitions to macro atom level indices
    pd.Series
        Series with unique source levels as index and their assigned indices as values
    &quot;&quot;&quot;
    unique_source_index = pd.MultiIndex.from_tuples(
        macro_atom_transition_metadata.source.unique(),
        names=[&quot;atomic_number&quot;, &quot;ion_number&quot;, &quot;level_number&quot;],
    )
    unique_source_series = pd.Series(
        index=unique_source_index,
        data=range(len(macro_atom_transition_metadata.source.unique())),
    )
    line2macro_level_upper = unique_source_series.loc[lines_level_upper]

    return line2macro_level_upper, unique_source_series</div>



<div class="viewcode-block" id="normalize_transition_probabilities">
<a class="viewcode-back" href="../../../../api/tardis.opacities.macro_atom.macroatom_solver.html#tardis.opacities.macro_atom.macroatom_solver.normalize_transition_probabilities">[docs]</a>
def normalize_transition_probabilities(
    probabilities_df: pd.DataFrame,
) -&gt; pd.DataFrame:
    &quot;&quot;&quot;
    Normalize transition probabilities by their source levels.

    Parameters
    ----------
    probabilities_df : pd.DataFrame
        DataFrame containing transition probabilities with a &#39;source&#39; column
        for grouping.

    Returns
    -------
    pd.DataFrame
        Normalized probabilities where each source group sums to 1.0.
        NaN values are replaced with 0.0 for cases where all transition
        probabilities are zero (typically ground levels in macroatom).
    &quot;&quot;&quot;
    # Normalize the probabilities by source. This used to be optional but is never not done in TARDIS.
    normalized_probabilities = probabilities_df.div(
        probabilities_df.groupby(&quot;source&quot;).transform(&quot;sum&quot;),
    )
    normalized_probabilities.replace(np.nan, 0, inplace=True)

    return normalized_probabilities.drop(columns=[&quot;source&quot;])</div>



<div class="viewcode-block" id="reindex_sort_and_clean_probabilities_and_metadata">
<a class="viewcode-back" href="../../../../api/tardis.opacities.macro_atom.macroatom_solver.html#tardis.opacities.macro_atom.macroatom_solver.reindex_sort_and_clean_probabilities_and_metadata">[docs]</a>
def reindex_sort_and_clean_probabilities_and_metadata(
    normalized_probabilities: pd.DataFrame,
    macro_atom_transition_metadata: pd.DataFrame,
) -&gt; tuple[pd.DataFrame, pd.DataFrame]:
    &quot;&quot;&quot;
    Reindex and sort macro atom transition probabilities and metadata. Also creates the unique metadata ID.

    Parameters
    ----------
    normalized_probabilities : pd.DataFrame
        DataFrame containing normalized transition probabilities.
    macro_atom_transition_metadata : pd.DataFrame
        DataFrame containing metadata for macro atom transitions.

    Returns
    -------
    tuple[pd.DataFrame, pd.DataFrame]
        Reindexed normalized probabilities and cleaned metadata sorted by
        atomic number, ion number, and source level.
    &quot;&quot;&quot;
    normalized_probabilities = normalized_probabilities.reset_index(
        drop=True
    )  # Reset to create a unique macro_atom_transition_id.
    normalized_probabilities.index.rename(
        &quot;macro_atom_transition_id&quot;, inplace=True
    )

    macro_atom_transition_metadata = (
        macro_atom_transition_metadata.reset_index()
    )
    macro_atom_transition_metadata.index.rename(
        &quot;macro_atom_transition_id&quot;, inplace=True
    )
    macro_atom_transition_metadata[&quot;source_level&quot;] = (
        macro_atom_transition_metadata.source.apply(lambda x: x[2])
    )
    macro_atom_transition_metadata = macro_atom_transition_metadata.sort_values(
        [
            &quot;atomic_number&quot;,
            &quot;ion_number&quot;,
            &quot;source_level&quot;,
            &quot;macro_atom_transition_id&quot;,
        ],
        kind=SORTING_ALGORITHM,
    )  # This is how carsus sorted the macro atom transitions, then also using macro_atom_transition_id to break ties.

    normalized_probabilities = normalized_probabilities.loc[
        macro_atom_transition_metadata.index
    ]  # Reorder to match the metadata, which was sorted to match carsus.

    return normalized_probabilities, macro_atom_transition_metadata</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2013-2025, TARDIS Collaboration.
      <span class="lastupdated">Last updated on 06 Oct 2025.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>