

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-53HJHD1BWS"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-53HJHD1BWS');
    </script>
    
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>tardis.spectrum.formal_integral &mdash; tardis</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />

  
    <link rel="shortcut icon" href="../../../_static/tardis_logo.ico"/>
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@1.0.13/dist/embed-amd.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link href="../../../_static/tardis.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            tardis
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart.html">Quickstart for TARDIS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../how_to_guides.html">How-To Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../workflows.html">Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/modules.html">API</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Input/Output</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../io/hdf/index.html">Hierarchical Data Format (HDF5)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../io/configuration/index.html">Configuration (Required Input)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../io/model/index.html">Reading Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../io/optional/index.html">Optional Inputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../io/output/index.html">Additional Outputs</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Analyzing Tardis</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../analyzing_tardis/visualization/index.html">Visualization Tools &amp; Widgets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../analyzing_tardis/spectrum/index.html">Analyzing TARDIS Spectra</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../analyzing_tardis/liv_plot_notebook.html">Analyzing Last Interaction Velocity (LIV) Distribution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../analyzing_tardis/rpacket_plot_notebook.html">Analysing Montecarlo Packets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../analyzing_tardis/analysing_convergence_plot.html">Convergence Plots</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Physics Walkthrough</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../physics/intro/index.html">Physics Walkthrough Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../physics/setup/index.html">Setting Up the Simulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../physics/montecarlo/index.html">Monte Carlo Iteration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../physics/update_and_conv/update_and_conv.html">Updating Plasma and Convergence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../physics/spectrum/index.html">Spectrum Generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../physics/tardisgamma/index.html">TARDIS-High Energy</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contributing to TARDIS</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing/CONTRIBUTING.html">Contribution Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing/development/index.html">Developer Workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing/tools/index.html">Developer Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing/CHANGELOG.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing/in_progress/index.html">Features In-Progress</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Other Resources</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../resources/credits.html">Credits &amp; Publication Policies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../resources/research_done_using_TARDIS/research_papers.html">Papers Using TARDIS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../resources/code_comparison/index.html">Code Comparison</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../resources/zreferences.html">References and Glossary</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">tardis</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">tardis.spectrum.formal_integral</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for tardis.spectrum.formal_integral</h1><div class="highlight"><pre>
<span></span>import warnings

import numpy as np
import pandas as pd
import scipy.sparse as sp
import scipy.sparse.linalg as linalg
from astropy import units as u
from numba import njit, prange
from scipy.interpolate import interp1d

from tardis import constants as const
from tardis.opacities.continuum.continuum_state import ContinuumState
from tardis.opacities.opacity_state import (
    OpacityState,
    opacity_state_initialize,
)
from tardis.spectrum.formal_integral_cuda import (
    CudaFormalIntegrator,
)
from tardis.spectrum.spectrum import TARDISSpectrum
from tardis.transport.montecarlo import njit_dict, njit_dict_no_parallel
from tardis.transport.montecarlo.configuration import montecarlo_globals
from tardis.transport.montecarlo.configuration.constants import SIGMA_THOMSON

C_INV = 3.33564e-11
PI = np.pi
KB_CGS = 1.3806488e-16
H_CGS = 6.62606957e-27


<div class="viewcode-block" id="IntegrationError">
<a class="viewcode-back" href="../../../api/tardis.spectrum.formal_integral.html#tardis.spectrum.formal_integral.IntegrationError">[docs]</a>
class IntegrationError(Exception):
    pass</div>



<div class="viewcode-block" id="numba_formal_integral">
<a class="viewcode-back" href="../../../api/tardis.spectrum.formal_integral.html#tardis.spectrum.formal_integral.numba_formal_integral">[docs]</a>
@njit(**njit_dict)
def numba_formal_integral(
    geometry,
    time_explosion,
    plasma,
    iT,
    inu,
    inu_size,
    att_S_ul,
    Jred_lu,
    Jblue_lu,
    tau_sobolev,
    electron_density,
    N,
):
    &quot;&quot;&quot;
    Returns
    -------
    L : float64 array
        integrated luminosities
    I_nu_p : float64 2D array
        intensities at each p-ray multiplied by p
        frequency x p-ray grid
    &quot;&quot;&quot;
    # TODO: add all the original todos
    # Initialize the output which is shared among threads
    L = np.zeros(inu_size, dtype=np.float64)
    # global read-only values
    size_line, size_shell = tau_sobolev.shape
    size_tau = size_line * size_shell
    R_ph = geometry.r_inner[0]  # make sure these are cgs
    R_max = geometry.r_outer[size_shell - 1]
    pp = np.zeros(N, dtype=np.float64)  # check
    exp_tau = np.zeros(size_tau, dtype=np.float64)
    exp_tau = np.exp(-tau_sobolev.T.ravel())  # maybe make this 2D?
    pp[::] = calculate_p_values(R_max, N)
    line_list_nu = plasma.line_list_nu
    # done with instantiation
    # now loop over wavelength in spectrum
    I_nu_p = np.zeros((inu_size, N), dtype=np.float64)
    for nu_idx in prange(inu_size):
        I_nu = I_nu_p[nu_idx]
        z = np.zeros(2 * size_shell, dtype=np.float64)
        shell_id = np.zeros(2 * size_shell, dtype=np.int64)
        offset = 0
        size_z = 0
        idx_nu_start = 0
        direction = 0
        first = 0
        i = 0
        p = 0.0
        nu_start = 0.0
        nu_end = 0.0
        nu = 0.0
        zstart = 0.0
        zend = 0.0
        escat_contrib = 0.0
        escat_op = 0.0
        Jkkp = 0.0
        pexp_tau = 0
        patt_S_ul = 0
        pJred_lu = 0
        pJblue_lu = 0
        pline = 0

        nu = inu[nu_idx]
        # now loop over discrete values along line
        for p_idx in range(1, N):
            escat_contrib = 0
            p = pp[p_idx]

            # initialize z intersections for p values
            size_z = populate_z(
                geometry, time_explosion, p, z, shell_id
            )  # check returns
            # initialize I_nu
            if p &lt;= R_ph:
                I_nu[p_idx] = intensity_black_body(nu * z[0], iT)
            else:
                I_nu[p_idx] = 0

            # find first contributing lines
            nu_start = nu * z[0]
            nu_end = nu * z[1]
            idx_nu_start = line_search(plasma.line_list_nu, nu_start, size_line)
            offset = shell_id[0] * size_line
            # start tracking accumulated e-scattering optical depth
            zstart = time_explosion / C_INV * (1.0 - z[0])
            # Initialize &quot;pointers&quot;
            pline = int(idx_nu_start)
            pexp_tau = int(offset + idx_nu_start)
            patt_S_ul = int(offset + idx_nu_start)
            pJred_lu = int(offset + idx_nu_start)
            pJblue_lu = int(offset + idx_nu_start)

            # flag for first contribution to integration on current p-ray
            first = 1
            nu_ends = nu * z[1:]
            nu_ends_idxs = size_line - np.searchsorted(
                line_list_nu[::-1], nu_ends, side=&quot;right&quot;
            )
            # loop over all interactions
            for i in range(size_z - 1):
                escat_op = electron_density[int(shell_id[i])] * SIGMA_THOMSON
                nu_end = nu_ends[i]
                nu_end_idx = nu_ends_idxs[i]
                for _ in range(max(nu_end_idx - pline, 0)):
                    # calculate e-scattering optical depth to next resonance point
                    zend = (
                        time_explosion
                        / C_INV
                        * (1.0 - line_list_nu[pline] / nu)
                    )  # check

                    if first == 1:
                        # first contribution to integration
                        # NOTE: this treatment of I_nu_b (given
                        #   by boundary conditions) is not in Lucy 1999;
                        #   should be re-examined carefully
                        escat_contrib += (
                            (zend - zstart)
                            * escat_op
                            * (Jblue_lu[pJblue_lu] - I_nu[p_idx])
                        )
                        first = 0
                    else:
                        # Account for e-scattering, c.f. Eqs 27, 28 in Lucy 1999
                        Jkkp = 0.5 * (Jred_lu[pJred_lu] + Jblue_lu[pJblue_lu])
                        escat_contrib += (
                            (zend - zstart) * escat_op * (Jkkp - I_nu[p_idx])
                        )
                        # this introduces the necessary ffset of one element between
                        # pJblue_lu and pJred_lu
                        pJred_lu += 1
                    I_nu[p_idx] += escat_contrib
                    # // Lucy 1999, Eq 26
                    I_nu[p_idx] *= exp_tau[pexp_tau]
                    I_nu[p_idx] += att_S_ul[patt_S_ul]

                    # // reset e-scattering opacity
                    escat_contrib = 0
                    zstart = zend

                    pline += 1
                    pexp_tau += 1
                    patt_S_ul += 1
                    pJblue_lu += 1

                # calculate e-scattering optical depth to grid cell boundary

                Jkkp = 0.5 * (Jred_lu[pJred_lu] + Jblue_lu[pJblue_lu])
                zend = time_explosion / C_INV * (1.0 - nu_end / nu)  # check
                escat_contrib += (
                    (zend - zstart) * escat_op * (Jkkp - I_nu[p_idx])
                )
                zstart = zend

                # advance pointers
                direction = int((shell_id[i + 1] - shell_id[i]) * size_line)
                pexp_tau += direction
                patt_S_ul += direction
                pJred_lu += direction
                pJblue_lu += direction
            I_nu[p_idx] *= p
        L[nu_idx] = 8 * PI * PI * trapezoid_integration(I_nu, R_max / N)

    return L, I_nu_p</div>



# integrator_spec = [
#    (&quot;model&quot;, NumbaModel.class_type.instance_type),
#    (&quot;plasma&quot;, OpacityState.class_type.instance_type),
#    (&quot;points&quot;, int64),
# ]


# @jitclass(integrator_spec)
<div class="viewcode-block" id="NumbaFormalIntegrator">
<a class="viewcode-back" href="../../../api/tardis.spectrum.formal_integral.html#tardis.spectrum.formal_integral.NumbaFormalIntegrator">[docs]</a>
class NumbaFormalIntegrator:
    &quot;&quot;&quot;
    Helper class for performing the formal integral
    with numba.
    &quot;&quot;&quot;

    def __init__(self, geometry, time_explosion, plasma, points=1000):
        self.geometry = geometry
        self.time_explosion = time_explosion
        self.plasma = plasma
        self.points = points

<div class="viewcode-block" id="NumbaFormalIntegrator.formal_integral">
<a class="viewcode-back" href="../../../api/tardis.spectrum.formal_integral.html#tardis.spectrum.formal_integral.NumbaFormalIntegrator.formal_integral">[docs]</a>
    def formal_integral(
        self,
        iT,
        inu,
        inu_size,
        att_S_ul,
        Jred_lu,
        Jblue_lu,
        tau_sobolev,
        electron_density,
        N,
    ):
        &quot;&quot;&quot;
        Simple wrapper for the numba implementation of the formal integral
        &quot;&quot;&quot;
        return numba_formal_integral(
            self.geometry,
            self.time_explosion,
            self.plasma,
            iT,
            inu,
            inu_size,
            att_S_ul,
            Jred_lu,
            Jblue_lu,
            tau_sobolev,
            electron_density,
            N,
        )</div>
</div>



<div class="viewcode-block" id="FormalIntegrator">
<a class="viewcode-back" href="../../../api/tardis.spectrum.formal_integral.html#tardis.spectrum.formal_integral.FormalIntegrator">[docs]</a>
class FormalIntegrator:
    &quot;&quot;&quot;
    Class containing the formal integrator.

    If there is a NVIDIA CUDA GPU available,
    the formal integral will automatically run
    on it. If multiple GPUs are available, it will
    choose the first one that it sees. You can
    read more about selecting different GPUs on
    Numba&#39;s CUDA documentation.

    Parameters
    ----------
    model : tardis.model.SimulationState
    plasma : tardis.plasma.BasePlasma
    transport : tardis.transport.montecarlo.MontecarloTransport
    points : int64
    &quot;&quot;&quot;

    def __init__(
        self,
        simulation_state,
        plasma,
        transport,
        opacity_state=None,
        macro_atom_state=None,
        points=1000,
    ):
        self.simulation_state = simulation_state
        self.transport = transport
        self.points = points
        if transport:
            self.montecarlo_configuration = (
                self.transport.montecarlo_configuration
            )
        if plasma and opacity_state and macro_atom_state:
            self.opacity_state = opacity_state.to_numba(
                macro_atom_state,
                transport.line_interaction_type,
            )
            self.atomic_data = plasma.atomic_data
            self.plasma = plasma
            self.levels_index = plasma.levels
        elif plasma:
            self.opacity_state = opacity_state_initialize(
                plasma,
                transport.line_interaction_type,
                self.montecarlo_configuration.DISABLE_LINE_SCATTERING,
            )
            self.atomic_data = plasma.atomic_data
            self.plasma = plasma
            self.levels_index = plasma.levels
        else:
            self.opacity_state = None

<div class="viewcode-block" id="FormalIntegrator.generate_numba_objects">
<a class="viewcode-back" href="../../../api/tardis.spectrum.formal_integral.html#tardis.spectrum.formal_integral.FormalIntegrator.generate_numba_objects">[docs]</a>
    def generate_numba_objects(self):
        &quot;&quot;&quot;instantiate the numba interface objects
        needed for computing the formal integral
        &quot;&quot;&quot;
        from tardis.model.geometry.radial1d import NumbaRadial1DGeometry

        self.numba_radial_1d_geometry = NumbaRadial1DGeometry(
            self.transport.r_inner_i,
            self.transport.r_outer_i,
            self.transport.r_inner_i
            / self.simulation_state.time_explosion.to(&quot;s&quot;).value,
            self.transport.r_outer_i
            / self.simulation_state.time_explosion.to(&quot;s&quot;).value,
        )
        if self.opacity_state is None:
            self.opacity_state = opacity_state_initialize(
                self.plasma,
                self.transport.line_interaction_type,
                self.montecarlo_configuration.DISABLE_LINE_SCATTERING,
            )
        if self.transport.use_gpu:
            self.integrator = CudaFormalIntegrator(
                self.numba_radial_1d_geometry,
                self.simulation_state.time_explosion.cgs.value,
                self.opacity_state,
                self.points,
            )
        else:
            self.integrator = NumbaFormalIntegrator(
                self.numba_radial_1d_geometry,
                self.simulation_state.time_explosion.cgs.value,
                self.opacity_state,
                self.points,
            )</div>


<div class="viewcode-block" id="FormalIntegrator.check">
<a class="viewcode-back" href="../../../api/tardis.spectrum.formal_integral.html#tardis.spectrum.formal_integral.FormalIntegrator.check">[docs]</a>
    def check(self, raises=True):
        &quot;&quot;&quot;
        A method that determines if the formal integral can be performed with
        the current configuration settings

        The function returns False if the configuration conflicts with the
        required settings. If raises evaluates to True, then a
        IntegrationError is raised instead
        &quot;&quot;&quot;

        def raise_or_return(message):
            if raises:
                raise IntegrationError(message)
            else:
                warnings.warn(message)
                return False

        for obj in (self.simulation_state, self.plasma, self.transport):
            if obj is None:
                return raise_or_return(
                    &quot;The integrator is missing either model, plasma or &quot;
                    &quot;transport. Please make sure these are provided to the &quot;
                    &quot;FormalIntegrator.&quot;
                )

        if self.transport.line_interaction_type not in [
            &quot;downbranch&quot;,
            &quot;macroatom&quot;,
        ]:
            return raise_or_return(
                &quot;The FormalIntegrator currently only works for &quot;
                &#39;line_interaction_type == &quot;downbranch&quot;&#39;
                &#39;and line_interaction_type == &quot;macroatom&quot;&#39;
            )

        if montecarlo_globals.CONTINUUM_PROCESSES_ENABLED:
            return raise_or_return(
                &quot;The FormalIntegrator currently does not work for &quot;
                &quot;continuum interactions.&quot;
            )

        return True</div>


<div class="viewcode-block" id="FormalIntegrator.calculate_spectrum">
<a class="viewcode-back" href="../../../api/tardis.spectrum.formal_integral.html#tardis.spectrum.formal_integral.FormalIntegrator.calculate_spectrum">[docs]</a>
    def calculate_spectrum(
        self, frequency, points=None, interpolate_shells=0, raises=True
    ):
        # Very crude implementation
        # The c extension needs bin centers (or something similar)
        # while TARDISSpectrum needs bin edges
        self.check(raises)
        N = points or self.points
        if interpolate_shells == 0:  # Default Value
            interpolate_shells = max(2 * self.simulation_state.no_of_shells, 80)
            warnings.warn(
                &quot;The number of interpolate_shells was not &quot;
                f&quot;specified. The value was set to {interpolate_shells}.&quot;
            )
        self.interpolate_shells = interpolate_shells
        frequency = frequency.to(&quot;Hz&quot;, u.spectral())

        luminosity = u.Quantity(self.formal_integral(frequency, N), &quot;erg&quot;) * (
            frequency[1] - frequency[0]
        )

        # Ugly hack to convert to &#39;bin edges&#39;
        frequency = u.Quantity(
            np.concatenate(
                [
                    frequency.value,
                    [frequency.value[-1] + np.diff(frequency.value)[-1]],
                ]
            ),
            frequency.unit,
        )

        return TARDISSpectrum(frequency, luminosity)</div>


<div class="viewcode-block" id="FormalIntegrator.make_source_function">
<a class="viewcode-back" href="../../../api/tardis.spectrum.formal_integral.html#tardis.spectrum.formal_integral.FormalIntegrator.make_source_function">[docs]</a>
    def make_source_function(self):
        &quot;&quot;&quot;
        Calculates the source function using the line absorption rate estimator `Edotlu_estimator`

        Formally it calculates the expression ( 1 - exp(-tau_ul) ) S_ul but this product is what we need later,
        so there is no need to factor out the source function explicitly.

        Parameters
        ----------
        model : tardis.model.SimulationState

        Returns
        -------
        Numpy array containing ( 1 - exp(-tau_ul) ) S_ul ordered by wavelength of the transition u -&gt; l
        &quot;&quot;&quot;

        simulation_state = self.simulation_state
        # slice for the active shells
        local_slice = slice(
            simulation_state.geometry.v_inner_boundary_index,
            simulation_state.geometry.v_outer_boundary_index,
        )

        transport = self.transport
        montecarlo_transport_state = transport.transport_state
        transition_probabilities = self.opacity_state.transition_probabilities[
            :, local_slice
        ]
        tau_sobolevs = self.opacity_state.tau_sobolev[:, local_slice]

        columns = range(simulation_state.no_of_shells)

        # macro_ref = self.atomic_data.macro_atom_references
        macro_ref = self.atomic_data.macro_atom_references
        # macro_data = self.atomic_data.macro_atom_data
        macro_data = self.plasma.atomic_data.macro_atom_data

        no_lvls = len(self.levels_index)
        no_shells = len(simulation_state.dilution_factor)

        if transport.line_interaction_type == &quot;macroatom&quot;:
            internal_jump_mask = (macro_data.transition_type &gt;= 0).values
            ma_int_data = macro_data[internal_jump_mask]
            internal = transition_probabilities[internal_jump_mask]

            source_level_idx = ma_int_data.source_level_idx.values
            destination_level_idx = ma_int_data.destination_level_idx.values

        Edotlu_norm_factor = 1 / (
            montecarlo_transport_state.packet_collection.time_of_simulation
            * simulation_state.volume
        )
        exptau = 1 - np.exp(-tau_sobolevs)
        Edotlu = (
            Edotlu_norm_factor
            * exptau
            * montecarlo_transport_state.radfield_mc_estimators.Edotlu_estimator
        )

        # The following may be achieved by calling the appropriate plasma
        # functions
        Jbluelu_norm_factor = (
            (
                const.c.cgs
                * simulation_state.time_explosion
                / (
                    4
                    * np.pi
                    * montecarlo_transport_state.time_of_simulation
                    * simulation_state.volume
                )
            )
            .to(&quot;1/(cm^2 s)&quot;)
            .value
        )
        # Jbluelu should already by in the correct order, i.e. by wavelength of
        # the transition l-&gt;u
        Jbluelu = (
            transport.transport_state.radfield_mc_estimators.j_blue_estimator
            * Jbluelu_norm_factor
        )

        upper_level_index = self.atomic_data.lines.index.droplevel(
            &quot;level_number_lower&quot;
        )
        e_dot_lu = pd.DataFrame(
            Edotlu.value, index=upper_level_index, columns=columns
        )
        e_dot_u = e_dot_lu.groupby(level=[0, 1, 2]).sum()
        e_dot_u_src_idx = macro_ref.loc[e_dot_u.index].references_idx.values

        if transport.line_interaction_type == &quot;macroatom&quot;:
            C_frame = pd.DataFrame(columns=columns, index=macro_ref.index)
            q_indices = (source_level_idx, destination_level_idx)
            for shell in range(no_shells):
                Q = sp.coo_matrix(
                    (internal[:, shell], q_indices), shape=(no_lvls, no_lvls)
                )
                inv_N = sp.identity(no_lvls) - Q
                e_dot_u_vec = np.zeros(no_lvls)
                e_dot_u_vec[e_dot_u_src_idx] = e_dot_u[shell].values
                C_frame[shell] = linalg.spsolve(inv_N.T, e_dot_u_vec)

        e_dot_u.index.names = [
            &quot;atomic_number&quot;,
            &quot;ion_number&quot;,
            &quot;source_level_number&quot;,
        ]  # To make the q_ul e_dot_u product work, could be cleaner
        transitions = self.plasma.atomic_data.macro_atom_data[
            self.plasma.atomic_data.macro_atom_data.transition_type == -1
        ].copy()
        transitions_index = transitions.set_index(
            [&quot;atomic_number&quot;, &quot;ion_number&quot;, &quot;source_level_number&quot;]
        ).index.copy()
        tmp = pd.DataFrame(
            transition_probabilities[
                (self.atomic_data.macro_atom_data.transition_type == -1).values
            ]
        )
        q_ul = tmp.set_index(transitions_index)
        t = simulation_state.time_explosion.value
        t = simulation_state.time_explosion.value
        lines = self.atomic_data.lines.set_index(&quot;line_id&quot;)
        wave = lines.wavelength_cm.loc[
            transitions.transition_line_id
        ].values.reshape(-1, 1)
        if transport.line_interaction_type == &quot;macroatom&quot;:
            e_dot_u = C_frame.loc[e_dot_u.index]
        att_S_ul = wave * (q_ul * e_dot_u) * t / (4 * np.pi)

        result = pd.DataFrame(
            att_S_ul.values,
            index=transitions.transition_line_id.values,
            columns=columns,
        )
        att_S_ul = result.loc[lines.index.values].values

        # Jredlu should already by in the correct order, i.e. by wavelength of
        # the transition l-&gt;u (similar to Jbluelu)
        Jredlu = Jbluelu * np.exp(-tau_sobolevs) + att_S_ul
        if self.interpolate_shells &gt; 0:
            (
                att_S_ul,
                Jredlu,
                Jbluelu,
                e_dot_u,
            ) = self.interpolate_integrator_quantities(
                att_S_ul, Jredlu, Jbluelu, e_dot_u
            )
        else:
            transport.r_inner_i = (
                montecarlo_transport_state.geometry_state.r_inner
            )
            transport.r_outer_i = (
                montecarlo_transport_state.geometry_state.r_outer
            )
            transport.tau_sobolevs_integ = self.opacity_state.tau_sobolev
            transport.electron_densities_integ = (
                self.opacity_state.electron_density
            )

        return att_S_ul, Jredlu, Jbluelu, e_dot_u</div>


<div class="viewcode-block" id="FormalIntegrator.interpolate_integrator_quantities">
<a class="viewcode-back" href="../../../api/tardis.spectrum.formal_integral.html#tardis.spectrum.formal_integral.FormalIntegrator.interpolate_integrator_quantities">[docs]</a>
    def interpolate_integrator_quantities(
        self, att_S_ul, Jredlu, Jbluelu, e_dot_u
    ):
        transport = self.transport
        mct_state = transport.transport_state
        plasma = self.plasma
        nshells = self.interpolate_shells
        r_middle = (
            mct_state.geometry_state.r_inner + mct_state.geometry_state.r_outer
        ) / 2.0

        r_integ = np.linspace(
            mct_state.geometry_state.r_inner[0],
            mct_state.geometry_state.r_outer[-1],
            nshells,
        )
        transport.r_inner_i = r_integ[:-1]
        transport.r_outer_i = r_integ[1:]

        r_middle_integ = (r_integ[:-1] + r_integ[1:]) / 2.0

        transport.electron_densities_integ = interp1d(
            r_middle,
            plasma.electron_densities.iloc[
                self.simulation_state.geometry.v_inner_boundary_index : self.simulation_state.geometry.v_outer_boundary_index
            ],
            fill_value=&quot;extrapolate&quot;,
            kind=&quot;nearest&quot;,
        )(r_middle_integ)
        # Assume tau_sobolevs to be constant within a shell
        # (as in the MC simulation)
        transport.tau_sobolevs_integ = interp1d(
            r_middle,
            self.opacity_state.tau_sobolev[
                :,
                self.simulation_state.geometry.v_inner_boundary_index : self.simulation_state.geometry.v_outer_boundary_index,
            ],
            fill_value=&quot;extrapolate&quot;,
            kind=&quot;nearest&quot;,
        )(r_middle_integ)
        att_S_ul = interp1d(r_middle, att_S_ul, fill_value=&quot;extrapolate&quot;)(
            r_middle_integ
        )
        Jredlu = interp1d(r_middle, Jredlu, fill_value=&quot;extrapolate&quot;)(
            r_middle_integ
        )
        Jbluelu = interp1d(r_middle, Jbluelu, fill_value=&quot;extrapolate&quot;)(
            r_middle_integ
        )
        e_dot_u = interp1d(r_middle, e_dot_u, fill_value=&quot;extrapolate&quot;)(
            r_middle_integ
        )

        # Set negative values from the extrapolation to zero
        att_S_ul = att_S_ul.clip(0.0)
        Jbluelu = Jbluelu.clip(0.0)
        Jredlu = Jredlu.clip(0.0)
        e_dot_u = e_dot_u.clip(0.0)
        return att_S_ul, Jredlu, Jbluelu, e_dot_u</div>


<div class="viewcode-block" id="FormalIntegrator.formal_integral">
<a class="viewcode-back" href="../../../api/tardis.spectrum.formal_integral.html#tardis.spectrum.formal_integral.FormalIntegrator.formal_integral">[docs]</a>
    def formal_integral(self, nu, N):
        &quot;&quot;&quot;Do the formal integral with the numba
        routines
        &quot;&quot;&quot;
        # TODO: get rid of storage later on

        res = self.make_source_function()

        att_S_ul = res[0].flatten(order=&quot;F&quot;)
        Jred_lu = res[1].flatten(order=&quot;F&quot;)
        Jblue_lu = res[2].flatten(order=&quot;F&quot;)

        self.generate_numba_objects()
        L, I_nu_p = self.integrator.formal_integral(
            self.simulation_state.t_inner,
            nu,
            nu.shape[0],
            att_S_ul,
            Jred_lu,
            Jblue_lu,
            self.transport.tau_sobolevs_integ,
            self.transport.electron_densities_integ,
            N,
        )
        R_max = self.transport.r_outer_i[-1]
        ps = calculate_p_values(R_max, N)[None, :]
        I_nu_p[:, 1:] /= ps[:, 1:]
        self.transport.I_nu_p = I_nu_p
        self.transport.p_rays = ps

        I_nu = self.transport.I_nu_p * ps
        L_test = np.array(
            [
                8 * PI * PI * trapezoid_integration((I_nu)[i, :], R_max / N)
                for i in range(nu.shape[0])
            ]
        )
        error = np.max(np.abs((L_test - L) / L))
        assert (
            error &lt; 1e-7
        ), f&quot;Incorrect I_nu_p values, max relative difference:{error}&quot;

        return np.array(L, np.float64)</div>
</div>



<div class="viewcode-block" id="populate_z">
<a class="viewcode-back" href="../../../api/tardis.spectrum.formal_integral.html#tardis.spectrum.formal_integral.populate_z">[docs]</a>
@njit(**njit_dict_no_parallel)
def populate_z(geometry, time_explosion, p, oz, oshell_id):
    &quot;&quot;&quot;Calculate p line intersections

    This function calculates the intersection points of the p-line with
    each shell

    Inputs:
        :p: (double) distance of the integration line to the center
        :oz: (array of doubles) will be set with z values. the array is truncated
                    by the value `1`.
        :oshell_id: (int64) will be set with the corresponding shell_ids
    &quot;&quot;&quot;
    # abbreviations
    r = geometry.r_outer
    N = len(geometry.r_inner)  # check
    inv_t = 1 / time_explosion
    z = 0
    offset = N

    if p &lt;= geometry.r_inner[0]:
        # intersect the photosphere
        for i in range(N):
            oz[i] = 1 - calculate_z(r[i], p, inv_t)
            oshell_id[i] = i
        return N
    else:
        # no intersection with photosphere
        # that means we intersect each shell twice
        for i in range(N):
            z = calculate_z(r[i], p, inv_t)
            if z == 0:
                continue
            if offset == N:
                offset = i
            # calculate the index in the resulting array
            i_low = N - i - 1  # the far intersection with the shell
            i_up = N + i - 2 * offset  # the nearer intersection with the shell

            # setting the arrays; check return them?
            oz[i_low] = 1 + z
            oshell_id[i_low] = i
            oz[i_up] = 1 - z
            oshell_id[i_up] = i
        return 2 * (N - offset)</div>



<div class="viewcode-block" id="calculate_z">
<a class="viewcode-back" href="../../../api/tardis.spectrum.formal_integral.html#tardis.spectrum.formal_integral.calculate_z">[docs]</a>
@njit(**njit_dict_no_parallel)
def calculate_z(r, p, inv_t):
    &quot;&quot;&quot;Calculate distance to p line

    Calculate half of the length of the p-line inside a shell
    of radius r in terms of unit length (c * t_exp).
    If shell and p-line do not intersect, return 0.

    Inputs:
        :r: (double) radius of the shell
        :p: (double) distance of the p-line to the center of the supernova
        :inv_t: (double) inverse time_explosio is needed to norm to unit-length
    &quot;&quot;&quot;
    if r &gt; p:
        return np.sqrt(r * r - p * p) * C_INV * inv_t
    else:
        return 0</div>



<div class="viewcode-block" id="BoundsError">
<a class="viewcode-back" href="../../../api/tardis.spectrum.formal_integral.html#tardis.spectrum.formal_integral.BoundsError">[docs]</a>
class BoundsError(IndexError):
    pass</div>



<div class="viewcode-block" id="line_search">
<a class="viewcode-back" href="../../../api/tardis.spectrum.formal_integral.html#tardis.spectrum.formal_integral.line_search">[docs]</a>
@njit(**njit_dict_no_parallel)
def line_search(nu, nu_insert, number_of_lines):
    &quot;&quot;&quot;
    Insert a value in to an array of line frequencies

    Inputs:
        :nu: (array) line frequencies
        :nu_insert: (int) value of nu key
        :number_of_lines: (int) number of lines in the line list

    Outputs:
        index of the next line ot the red.
                If the key value is redder
                 than the reddest line returns number_of_lines.
    &quot;&quot;&quot;
    # TODO: fix the TARDIS_ERROR_OK
    # tardis_error_t ret_val = TARDIS_ERROR_OK # check
    imin = 0
    imax = number_of_lines - 1
    if nu_insert &gt; nu[imin]:
        result = imin
    elif nu_insert &lt; nu[imax]:
        result = imax + 1
    else:
        result = reverse_binary_search(nu, nu_insert, imin, imax)
        result = result + 1
    return result</div>



<div class="viewcode-block" id="reverse_binary_search">
<a class="viewcode-back" href="../../../api/tardis.spectrum.formal_integral.html#tardis.spectrum.formal_integral.reverse_binary_search">[docs]</a>
@njit(**njit_dict_no_parallel)
def reverse_binary_search(x, x_insert, imin, imax):
    &quot;&quot;&quot;Look for a place to insert a value in an inversely sorted float array.

    Inputs:
        :x: (array) an inversely (largest to lowest) sorted float array
        :x_insert: (value) a value to insert
        :imin: (int) lower bound
        :imax: (int) upper bound

    Outputs:
        index of the next boundary to the left
    &quot;&quot;&quot;
    # ret_val = TARDIS_ERROR_OK # check
    if (x_insert &gt; x[imin]) or (x_insert &lt; x[imax]):
        raise BoundsError  # check
    return len(x) - 1 - np.searchsorted(x[::-1], x_insert, side=&quot;right&quot;)</div>



<div class="viewcode-block" id="trapezoid_integration">
<a class="viewcode-back" href="../../../api/tardis.spectrum.formal_integral.html#tardis.spectrum.formal_integral.trapezoid_integration">[docs]</a>
@njit(**njit_dict_no_parallel)
def trapezoid_integration(array, h):
    &quot;&quot;&quot;in the future, let&#39;s just replace
    this with the numpy trapz
    since it is numba compatable
    &quot;&quot;&quot;
    return np.trapz(array, dx=h)</div>



<div class="viewcode-block" id="intensity_black_body">
<a class="viewcode-back" href="../../../api/tardis.spectrum.formal_integral.html#tardis.spectrum.formal_integral.intensity_black_body">[docs]</a>
@njit(**njit_dict_no_parallel)
def intensity_black_body(nu, temperature):
    &quot;&quot;&quot;
    Calculate the blackbody intensity.

    Parameters
    ----------
    nu : float64
        frequency
    temperature : float64
        Temperature

    Returns
    -------
    float64
    &quot;&quot;&quot;
    if nu == 0:
        return np.nan  # to avoid ZeroDivisionError
    beta_rad = 1 / (KB_CGS * temperature)
    coefficient = 2 * H_CGS * C_INV * C_INV
    return coefficient * nu * nu * nu / (np.exp(H_CGS * nu * beta_rad) - 1)</div>



<div class="viewcode-block" id="calculate_p_values">
<a class="viewcode-back" href="../../../api/tardis.spectrum.formal_integral.html#tardis.spectrum.formal_integral.calculate_p_values">[docs]</a>
@njit(**njit_dict_no_parallel)
def calculate_p_values(R_max, N):
    &quot;&quot;&quot;This can probably be replaced with a simpler function&quot;&quot;&quot;
    return np.arange(N).astype(np.float64) * R_max / (N - 1)</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2013-2025, TARDIS Collaboration.
      <span class="lastupdated">Last updated on 19 May 2025.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>