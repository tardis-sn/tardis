

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-53HJHD1BWS"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-53HJHD1BWS');
    </script>
    
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>tardis.plasma.properties.atomic &mdash; tardis</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />

  
    <link rel="shortcut icon" href="../../../../_static/tardis_logo.ico"/>
      <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../_static/documentation_options.js?v=53bc6e61"></script>
      <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@1.0.13/dist/embed-amd.min.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link href="../../../../_static/tardis.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            tardis
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../getting_started/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../quickstart.html">Quickstart for TARDIS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../resources/credits.html">Credits &amp; Publication Policies</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/high_energy/run_high_energy_workflow.html">TARDIS High Energy Workflow Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../analyzing_tardis/visualization/tutorial_montecarlo_packet_visualization.html">Montecarlo Packet Visualization</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">How-to Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../how_to_guides.html">How-To Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../workflows.html">Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../analyzing_tardis/index.html">Analyszing TARDIS Simulation Outputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../io/configuration/tutorial_read_configuration.html">Reading a Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../io/optional/index.html">Optional Inputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../io/output/index.html">Additional Outputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../how-to/code_comparison/index.html">How to do Code Comparison using TARDIS</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Physics Walkthrough</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../physics_walkthrough/intro/index.html">Physics Walkthrough Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../physics_walkthrough/setup/index.html">Setting Up the Simulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../physics_walkthrough/montecarlo/index.html">Monte Carlo Iteration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../physics_walkthrough/update_and_conv/update_and_conv.html">Updating Plasma and Convergence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../physics_walkthrough/spectrum/index.html">Spectrum Generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../physics_walkthrough/tardisgamma/index.html">TARDIS-High Energy</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/modules.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../reference/faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../reference/visualization_reference.html">Visualization Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../io/configuration/index.html">Configuration Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../io/hdf/index.html">Hierarchical Data Format (HDF5) Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contributing/CHANGELOG.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../resources/research_done_using_TARDIS/research_papers.html">Papers Using TARDIS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../resources/zreferences.html">Bibliography and Glossary</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contributing to TARDIS</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../contributing/CONTRIBUTING.html">Contribution Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contributing/development/index.html">Developer Workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contributing/tools/index.html">Developer Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contributing/in_progress/index.html">Features In-Progress</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">tardis</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">tardis.plasma.properties.atomic</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for tardis.plasma.properties.atomic</h1><div class="highlight"><pre>
<span></span>import logging
from collections import Counter as counter

import numpy as np
import pandas as pd
from numba import njit
from scipy.interpolate import PchipInterpolator
from scipy.special import exp1

from tardis.plasma.exceptions import IncompleteAtomicData
from tardis.plasma.properties.base import (
    BaseAtomicDataProperty,
    HiddenPlasmaProperty,
    ProcessingPlasmaProperty,
)
from tardis.plasma.properties.continuum_processes.rates import (
    A0,
    BETA_COLL,
    K_B,
    M_E,
    H,
    get_ground_state_multi_index,
)
from tardis.configuration.sorting_globals import SORTING_ALGORITHM

logger = logging.getLogger(__name__)

__all__ = [
    &quot;Levels&quot;,
    &quot;Lines&quot;,
    &quot;LinesLowerLevelIndex&quot;,
    &quot;LinesUpperLevelIndex&quot;,
    &quot;IonizationData&quot;,
    &quot;ZetaData&quot;,
    &quot;NLTEData&quot;,
    &quot;MacroAtomData&quot;,
    &quot;PhotoIonizationData&quot;,
    &quot;YgData&quot;,
    &quot;YgInterpolator&quot;,
    &quot;LevelIdxs2LineIdx&quot;,
    &quot;LevelIdxs2TransitionIdx&quot;,
    &quot;TwoPhotonData&quot;,
    &quot;ContinuumInteractionHandler&quot;,
]


<div class="viewcode-block" id="Levels">
<a class="viewcode-back" href="../../../../api/tardis.plasma.properties.atomic.html#tardis.plasma.properties.atomic.Levels">[docs]</a>
class Levels(BaseAtomicDataProperty):
    &quot;&quot;&quot;
    Attributes
    ----------
    levels : pandas.MultiIndex
        (atomic_number, ion_number, level_number)
        Index of filtered atomic data. Index used for all other attribute dataframes for this class
    excitation_energy : pandas.DataFrame, dtype float
        Excitation energies of atomic levels.
        Index is levels.
    metastability : pandas.DataFrame, dtype bool
        Records whether atomic levels are metastable.
        Index is levels.
    g : pandas.DataFrame (index=levels), dtype float
        Statistical weights of atomic levels.
    &quot;&quot;&quot;

    outputs = (&quot;levels&quot;, &quot;excitation_energy&quot;, &quot;metastability&quot;, &quot;g&quot;)
    latex_name = (
        r&quot;\textrm{levels}&quot;,
        r&quot;\epsilon_{\textrm{k}}&quot;,
        r&quot;\textrm{metastability}&quot;,
        &quot;g&quot;,
    )

    def _filter_atomic_property(self, levels, selected_atoms):
        return levels[levels.index.isin(selected_atoms, level=&quot;atomic_number&quot;)]

    def _set_index(self, levels):
        return (
            levels.index,
            levels[&quot;energy&quot;],
            levels[&quot;metastable&quot;],
            levels[&quot;g&quot;],
        )</div>



<div class="viewcode-block" id="Lines">
<a class="viewcode-back" href="../../../../api/tardis.plasma.properties.atomic.html#tardis.plasma.properties.atomic.Lines">[docs]</a>
class Lines(BaseAtomicDataProperty):
    &quot;&quot;&quot;
    Attributes
    ----------
    lines : pandas.DataFrame
        Atomic lines data. Columns are wavelength, atomic_number,ion_number,
        f_ul, f_lu, level_number_lower, level_number_upper, nu, B_lu, B_ul, A_ul,
        wavelength. Index is line_id.
    nu : pandas.DataFrame, dtype float
        Line frequency data. Index is line_id.
    f_lu : pandas.DataFrame, dtype float
        Transition probability data. Index is line_id.
    wavelength_cm : pandas.DataFrame, dtype float
        Line wavelengths in cm. Index is line_id.
    &quot;&quot;&quot;

    # Would like for lines to just be the line_id values
    outputs = (&quot;lines&quot;, &quot;nu&quot;, &quot;f_lu&quot;, &quot;wavelength_cm&quot;)

    latex_name = (
        r&quot;\textrm{lines}&quot;,
        r&quot;\nu&quot;,
        r&quot;f_lu&quot;,
        r&quot;\lambda_{cm}&quot;,
    )

    def _filter_atomic_property(self, lines, selected_atoms):
        # return lines[lines.atomic_number.isin(selected_atoms)]
        return lines

    def _set_index(self, lines):
        # lines.set_index(&#39;line_id&#39;, inplace=True)
        return lines, lines[&quot;nu&quot;], lines[&quot;f_lu&quot;], lines[&quot;wavelength_cm&quot;]</div>



<div class="viewcode-block" id="MacroAtomData">
<a class="viewcode-back" href="../../../../api/tardis.plasma.properties.atomic.html#tardis.plasma.properties.atomic.MacroAtomData">[docs]</a>
class MacroAtomData(BaseAtomicDataProperty):
    outputs = (&quot;macro_atom_data&quot;,)

    def _filter_atomic_property(self, macro_atom_data, selected_atoms):
        return macro_atom_data

    def _set_index(self, macro_atom_data):
        return macro_atom_data</div>



<div class="viewcode-block" id="PhotoIonizationData">
<a class="viewcode-back" href="../../../../api/tardis.plasma.properties.atomic.html#tardis.plasma.properties.atomic.PhotoIonizationData">[docs]</a>
class PhotoIonizationData(ProcessingPlasmaProperty):
    &quot;&quot;&quot;
    Attributes
    ----------
    photo_ion_cross_sections : pandas.DataFrame, dtype float
        Photoionization cross sections as a function of frequency.
        Columns are nu, x_sect, index=(&#39;atomic_number&#39;,&#39;ion_number&#39;,&#39;level_number&#39;)
    photo_ion_block_references : numpy.ndarray, dtype int
        Indices where the photoionization data for
        a given level starts. Needed for calculation
        of recombination rates.
    nu_i : pandas.Series, dtype float
        Threshold frequencies for ionization
    energy_i : pandas.Series, dtype float
        Energies of levels with bound-free transitions. Needed to calculate
        for example internal transition probabilities in the macro atom scheme.
    photo_ion_index : pandas.MultiIndex, dtype int
        Atomic, ion and level numbers for which photoionization data exists.
    level2continuum_idx : pandas.Series, dtype int
        Maps a level MultiIndex (atomic_number, ion_number, level_number) to
        the continuum_idx of the corresponding bound-free continuum (which are
        sorted by decreasing frequency).
    level_idxs2continuum_idx : pandas.DataFrame, dtype int
        Maps a source_level_idx destination_level_idx pair to a continuum_idx.
    &quot;&quot;&quot;

    outputs = (
        &quot;photo_ion_cross_sections&quot;,
        &quot;photo_ion_block_references&quot;,
        &quot;photo_ion_index&quot;,
        &quot;nu_i&quot;,
        &quot;energy_i&quot;,
        &quot;photo_ion_idx&quot;,
        &quot;level2continuum_idx&quot;,
        &quot;level_idxs2continuum_idx&quot;,
    )
    latex_name = (
        r&quot;\xi_{\textrm{i}}(\nu)&quot;,
        &quot;&quot;,
        &quot;&quot;,
        r&quot;\nu_i&quot;,
        r&quot;\epsilon_i&quot;,
        &quot;&quot;,
        &quot;&quot;,
    )

<div class="viewcode-block" id="PhotoIonizationData.calculate">
<a class="viewcode-back" href="../../../../api/tardis.plasma.properties.atomic.html#tardis.plasma.properties.atomic.PhotoIonizationData.calculate">[docs]</a>
    def calculate(self, atomic_data, continuum_interaction_species):
        # photoionization_data = atomic_data.photoionization_data.set_index(
        #    [&quot;atomic_number&quot;, &quot;ion_number&quot;, &quot;level_number&quot;]
        # )
        photoionization_data = atomic_data.photoionization_data
        mask_selected_species = photoionization_data.index.droplevel(
            &quot;level_number&quot;
        ).isin(continuum_interaction_species)
        photoionization_data = photoionization_data[mask_selected_species]
        phot_nus = photoionization_data[&quot;nu&quot;]
        block_references = np.pad(
            phot_nus.groupby(level=[0, 1, 2]).count().values.cumsum(), [1, 0]
        )
        photo_ion_index = photoionization_data.index.unique()
        nu_i = photoionization_data.groupby(level=[0, 1, 2]).first().nu
        energy_i = atomic_data.levels.loc[photo_ion_index].energy

        source_idx = atomic_data.macro_atom_references.loc[
            photo_ion_index
        ].references_idx
        destination_idx = atomic_data.macro_atom_references.loc[
            get_ground_state_multi_index(photo_ion_index)
        ].references_idx
        photo_ion_idx = pd.DataFrame(
            {
                &quot;source_level_idx&quot;: source_idx.values,
                &quot;destination_level_idx&quot;: destination_idx.values,
            },
            index=photo_ion_index,
        )

        level2continuum_edge_idx = pd.Series(
            np.arange(len(nu_i)),
            nu_i.sort_values(ascending=False, kind=SORTING_ALGORITHM).index,
            name=&quot;continuum_idx&quot;,
        )

        level_idxs2continuum_idx = photo_ion_idx.copy()
        level_idxs2continuum_idx[&quot;continuum_idx&quot;] = level2continuum_edge_idx
        level_idxs2continuum_idx = level_idxs2continuum_idx.set_index(
            [&quot;source_level_idx&quot;, &quot;destination_level_idx&quot;]
        )
        return (
            photoionization_data,
            block_references,
            photo_ion_index,
            nu_i,
            energy_i,
            photo_ion_idx,
            level2continuum_edge_idx,
            level_idxs2continuum_idx,
        )</div>
</div>



<div class="viewcode-block" id="ContinuumInteractionHandler">
<a class="viewcode-back" href="../../../../api/tardis.plasma.properties.atomic.html#tardis.plasma.properties.atomic.ContinuumInteractionHandler">[docs]</a>
class ContinuumInteractionHandler(ProcessingPlasmaProperty):
    outputs = (
        &quot;get_current_bound_free_continua&quot;,
        &quot;determine_bf_macro_activation_idx&quot;,
        &quot;determine_continuum_macro_activation_idx&quot;,
    )

<div class="viewcode-block" id="ContinuumInteractionHandler.calculate">
<a class="viewcode-back" href="../../../../api/tardis.plasma.properties.atomic.html#tardis.plasma.properties.atomic.ContinuumInteractionHandler.calculate">[docs]</a>
    def calculate(
        self,
        photo_ion_cross_sections,
        level2continuum_idx,
        photo_ion_idx,
        k_packet_idx,
    ):
        nus = photo_ion_cross_sections.nu.loc[
            level2continuum_idx.index
        ]  # Sort by descending frequency
        nu_mins = nus.groupby(level=[0, 1, 2], sort=False).first().values
        nu_maxs = nus.groupby(level=[0, 1, 2], sort=False).last().values

        @njit(error_model=&quot;numpy&quot;, fastmath=True)
        def get_current_bound_free_continua(nu):
            &quot;&quot;&quot;
            Determine bound-free continua for which absorption is possible.

            Parameters
            ----------
            nu : float
                Comoving frequency of the r-packet.

            Returns
            -------
            numpy.ndarray, dtype int
                Continuum ids for which absorption is possible for frequency `nu`.
            &quot;&quot;&quot;
            # searchsorted would be faster but would need stricter format for photoionization data
            current_continua = np.where(
                np.logical_and(nu &gt;= nu_mins, nu &lt;= nu_maxs)
            )[0]
            return current_continua

        destination_level_idxs = photo_ion_idx.loc[
            level2continuum_idx.index, &quot;destination_level_idx&quot;
        ].values

        @njit(error_model=&quot;numpy&quot;, fastmath=True)
        def determine_bf_macro_activation_idx(
            nu, chi_bf_contributions, active_continua
        ):
            &quot;&quot;&quot;
            Determine the macro atom activation level after bound-free absorption.

            Parameters
            ----------
            nu : float
                Comoving frequency of the r-packet.
            chi_bf_contributions : numpy.ndarray, dtype float
                Cumulative distribution of bound-free opacities at frequency
                `nu`.
            active_continua : numpy.ndarray, dtype int
                Continuum ids for which absorption is possible for frequency `nu`.

            Returns
            -------
            float
                Macro atom activation idx.
            &quot;&quot;&quot;
            # Perform a MC experiment to determine the continuum for absorption
            index = np.searchsorted(chi_bf_contributions, np.random.random())
            continuum_id = active_continua[index]

            # Perform a MC experiment to determine whether thermal or
            # ionization energy is created
            nu_threshold = nu_mins[continuum_id]
            fraction_ionization = nu_threshold / nu
            if (
                np.random.random() &lt; fraction_ionization
            ):  # Create ionization energy (i-packet)
                destination_level_idx = destination_level_idxs[continuum_id]
            else:  # Create thermal energy (k-packet)
                destination_level_idx = k_packet_idx
            return destination_level_idx

        @njit(error_model=&quot;numpy&quot;, fastmath=True)
        def determine_continuum_macro_activation_idx(
            nu, chi_bf, chi_ff, chi_bf_contributions, active_continua
        ):
            &quot;&quot;&quot;
            Determine the macro atom activation level after a continuum absorption.

            Parameters
            ----------
            nu : float
                Comoving frequency of the r-packet.
            chi_bf : numpy.ndarray, dtype float
                Bound-free opacity.
            chi_bf : numpy.ndarray, dtype float
                Free-free opacity.
            chi_bf_contributions : numpy.ndarray, dtype float
                Cumulative distribution of bound-free opacities at frequency
                `nu`.
            active_continua : numpy.ndarray, dtype int
                Continuum ids for which absorption is possible for frequency `nu`.

            Returns
            -------
            float
                Macro atom activation idx.
            &quot;&quot;&quot;
            fraction_bf = chi_bf / (chi_bf + chi_ff)
            # TODO: In principle, we can also decide here whether a Thomson
            # scattering event happens and need one less RNG call.
            if np.random.random() &lt; fraction_bf:  # Bound-free absorption
                destination_level_idx = determine_bf_macro_activation_idx(
                    nu, chi_bf_contributions, active_continua
                )
            else:  # Free-free absorption (i.e. k-packet creation)
                destination_level_idx = k_packet_idx
            return destination_level_idx

        return (
            get_current_bound_free_continua,
            determine_bf_macro_activation_idx,
            determine_continuum_macro_activation_idx,
        )</div>
</div>



<div class="viewcode-block" id="TwoPhotonData">
<a class="viewcode-back" href="../../../../api/tardis.plasma.properties.atomic.html#tardis.plasma.properties.atomic.TwoPhotonData">[docs]</a>
class TwoPhotonData(ProcessingPlasmaProperty):
    outputs = (&quot;two_photon_data&quot;, &quot;two_photon_idx&quot;)
    &quot;&quot;&quot;
    Attributes
    ----------
    two_photon_data : pandas.DataFrame, dtype float
    A DataFrame containing the *two photon decay data* with:
        index: atomic_number, ion_number, level_number_lower, level_number_upper
        columns: A_ul[1/s], nu0[Hz], alpha, beta, gamma
        alpha, beta, gamma are fit coefficients for the frequency dependent
        transition probability A(y) of the two photon decay. See Eq. 2 in
        Nussbaumer &amp; Schmutz (1984).
    two_photon_idx : pandas.DataFrame, dtype int
    &quot;&quot;&quot;

<div class="viewcode-block" id="TwoPhotonData.calculate">
<a class="viewcode-back" href="../../../../api/tardis.plasma.properties.atomic.html#tardis.plasma.properties.atomic.TwoPhotonData.calculate">[docs]</a>
    def calculate(self, atomic_data, continuum_interaction_species):
        two_photon_data = atomic_data.two_photon_data
        mask_selected_species = two_photon_data.index.droplevel(
            [&quot;level_number_lower&quot;, &quot;level_number_upper&quot;]
        ).isin(continuum_interaction_species)
        if not mask_selected_species.sum():
            raise IncompleteAtomicData(
                &quot;two photon transition data for the requested &quot;
                f&quot;continuum_interactions species: {continuum_interaction_species.values.tolist()}&quot;
            )
        two_photon_data = two_photon_data[mask_selected_species]
        index_lower = two_photon_data.index.droplevel(&quot;level_number_upper&quot;)
        index_upper = two_photon_data.index.droplevel(&quot;level_number_lower&quot;)
        source_idx = atomic_data.macro_atom_references.loc[
            index_upper
        ].references_idx
        destination_idx = atomic_data.macro_atom_references.loc[
            index_lower
        ].references_idx
        two_photon_idx = pd.DataFrame(
            {
                &quot;source_level_idx&quot;: source_idx.values,
                &quot;destination_level_idx&quot;: destination_idx.values,
            },
            index=two_photon_data.index,
        )
        if len(two_photon_data) != 1:
            raise NotImplementedError(
                &quot;Currently only one two-photon decay is supported but there &quot;
                f&quot;are {len(two_photon_data)} in the atomic data.&quot;
            )
        return two_photon_data, two_photon_idx</div>
</div>



<div class="viewcode-block" id="LinesLowerLevelIndex">
<a class="viewcode-back" href="../../../../api/tardis.plasma.properties.atomic.html#tardis.plasma.properties.atomic.LinesLowerLevelIndex">[docs]</a>
class LinesLowerLevelIndex(HiddenPlasmaProperty):
    &quot;&quot;&quot;
    Attributes
    ----------
    lines_lower_level_index : numpy.ndrarray, dtype int
        Levels data for lower levels of particular lines
    &quot;&quot;&quot;

    outputs = (&quot;lines_lower_level_index&quot;,)

<div class="viewcode-block" id="LinesLowerLevelIndex.calculate">
<a class="viewcode-back" href="../../../../api/tardis.plasma.properties.atomic.html#tardis.plasma.properties.atomic.LinesLowerLevelIndex.calculate">[docs]</a>
    def calculate(self, levels, lines):
        levels_index = pd.Series(
            np.arange(len(levels), dtype=np.int64), index=levels
        )
        lines_index = lines.index.droplevel(&quot;level_number_upper&quot;)
        return np.array(levels_index.loc[lines_index])</div>
</div>



<div class="viewcode-block" id="LinesUpperLevelIndex">
<a class="viewcode-back" href="../../../../api/tardis.plasma.properties.atomic.html#tardis.plasma.properties.atomic.LinesUpperLevelIndex">[docs]</a>
class LinesUpperLevelIndex(HiddenPlasmaProperty):
    &quot;&quot;&quot;
    Attributes
    ----------
    lines_upper_level_index : numpy.ndarray, dtype int
        Levels data for upper levels of particular lines
    &quot;&quot;&quot;

    outputs = (&quot;lines_upper_level_index&quot;,)

<div class="viewcode-block" id="LinesUpperLevelIndex.calculate">
<a class="viewcode-back" href="../../../../api/tardis.plasma.properties.atomic.html#tardis.plasma.properties.atomic.LinesUpperLevelIndex.calculate">[docs]</a>
    def calculate(self, levels, lines):
        levels_index = pd.Series(
            np.arange(len(levels), dtype=np.int64), index=levels
        )
        lines_index = lines.index.droplevel(&quot;level_number_lower&quot;)
        return np.array(levels_index.loc[lines_index])</div>
</div>



<div class="viewcode-block" id="LevelIdxs2LineIdx">
<a class="viewcode-back" href="../../../../api/tardis.plasma.properties.atomic.html#tardis.plasma.properties.atomic.LevelIdxs2LineIdx">[docs]</a>
class LevelIdxs2LineIdx(HiddenPlasmaProperty):
    &quot;&quot;&quot;
    Attributes
    ----------
    level_idxs2line_idx : pandas.Series, dtype int
        Maps a source_level_idx destination_level_idx pair to a line_idx.
    &quot;&quot;&quot;

    outputs = (&quot;level_idxs2line_idx&quot;,)

<div class="viewcode-block" id="LevelIdxs2LineIdx.calculate">
<a class="viewcode-back" href="../../../../api/tardis.plasma.properties.atomic.html#tardis.plasma.properties.atomic.LevelIdxs2LineIdx.calculate">[docs]</a>
    def calculate(self, atomic_data):
        index = pd.MultiIndex.from_arrays(
            [
                atomic_data.lines_upper2macro_reference_idx,
                atomic_data.lines_lower2macro_reference_idx,
            ],
            names=[&quot;source_level_idx&quot;, &quot;destination_level_idx&quot;],
        )
        level_idxs2line_idx = pd.Series(
            np.arange(len(index)), index=index, name=&quot;lines_idx&quot;
        )

        # Check for duplicate indices
        if level_idxs2line_idx.index.duplicated().any():
            logger.warning(
                &quot;Duplicate indices in level_idxs2line_idx. &quot;
                &quot;Dropping duplicates. &quot;
                &quot;This is an issue with the atomic data &amp; carsus. &quot;
                &quot;Once fixed upstream, this warning will be removed. &quot;
                &quot;This will raise an error in the future instead. &quot;
                &quot;See https://github.com/tardis-sn/carsus/issues/384&quot;
            )
            # This is necessary since pd.DataFrame.drop_duplicates()
            # does not remove duplicates if the data is different
            # and only the index is duplicated. See the example given
            # in the pandas documentation:
            # https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.drop_duplicates.html
            level_idxs2line_idx = level_idxs2line_idx[
                ~level_idxs2line_idx.index.duplicated()
            ]

        return level_idxs2line_idx</div>
</div>



<div class="viewcode-block" id="LevelIdxs2TransitionIdx">
<a class="viewcode-back" href="../../../../api/tardis.plasma.properties.atomic.html#tardis.plasma.properties.atomic.LevelIdxs2TransitionIdx">[docs]</a>
class LevelIdxs2TransitionIdx(HiddenPlasmaProperty):
    &quot;&quot;&quot;
    Attributes
    ----------
    level_idxs2transition_idx : pandas.DataFrame, dtype int
       Maps a source_level_idx destination_level_idx pair to a transition_idx
       and transition type.
    &quot;&quot;&quot;

    outputs = (&quot;level_idxs2transition_idx&quot;,)

<div class="viewcode-block" id="LevelIdxs2TransitionIdx.calculate">
<a class="viewcode-back" href="../../../../api/tardis.plasma.properties.atomic.html#tardis.plasma.properties.atomic.LevelIdxs2TransitionIdx.calculate">[docs]</a>
    def calculate(self, level_idxs2line_idx, level_idxs2continuum_idx):
        level_idxs2line_idx = level_idxs2line_idx.to_frame()
        level_idxs2line_idx.insert(1, &quot;transition_type&quot;, -1)

        level_idxs2continuum_idx = level_idxs2continuum_idx.copy()
        level_idxs2continuum_idx.insert(1, &quot;transition_type&quot;, -2)
        level_idxs2continuum_idx = level_idxs2continuum_idx.rename(
            columns=({&quot;continuum_idx&quot;: &quot;lines_idx&quot;})
        )

        names = level_idxs2continuum_idx.index.names
        level_idxs2continuum_idx = level_idxs2continuum_idx.swaplevel()
        level_idxs2continuum_idx.index.names = names

        # TODO: This should probably be defined somewhere else.
        # One possibility would be to attach it to the cooling properties as
        # a class attribute.
        index_cooling = pd.MultiIndex.from_product(
            [[&quot;k&quot;], [&quot;ff&quot;, &quot;adiabatic&quot;, &quot;bf&quot;]], names=names
        )
        num_cool = len(index_cooling)
        level_idxs2cooling_idx = pd.DataFrame(
            {
                &quot;lines_idx&quot;: np.ones(num_cool, dtype=int) * -1,
                &quot;transition_type&quot;: np.arange(-3, -3 - num_cool, -1),
            },
            index=index_cooling,
        )
        level_idxs2transition_idx = pd.concat(
            [
                level_idxs2continuum_idx,
                level_idxs2line_idx,
                level_idxs2cooling_idx,
            ]
        )

        # TODO: Add two-photon processes

        return level_idxs2transition_idx</div>
</div>



<div class="viewcode-block" id="IonizationData">
<a class="viewcode-back" href="../../../../api/tardis.plasma.properties.atomic.html#tardis.plasma.properties.atomic.IonizationData">[docs]</a>
class IonizationData(BaseAtomicDataProperty):
    &quot;&quot;&quot;
    Attributes
    ----------
    ionization_data : pandas.Series
        Holding ionization energies
        Indexed by atomic number, ion number.
    &quot;&quot;&quot;

    outputs = (&quot;ionization_data&quot;,)

    def _filter_atomic_property(self, ionization_data, selected_atoms):
        mask = ionization_data.index.isin(selected_atoms, level=&quot;atomic_number&quot;)
        ionization_data = ionization_data[mask]
        counts = ionization_data.groupby(level=&quot;atomic_number&quot;).count()

        if np.all(counts.index == counts):
            return ionization_data
        else:
            raise IncompleteAtomicData(
                f&quot;ionization data for the ion ({str(counts.index[counts.index != counts])}, {str(counts[counts.index != counts])})&quot;
            )

    def _set_index(self, ionization_data):
        return ionization_data</div>



<div class="viewcode-block" id="ZetaData">
<a class="viewcode-back" href="../../../../api/tardis.plasma.properties.atomic.html#tardis.plasma.properties.atomic.ZetaData">[docs]</a>
class ZetaData(BaseAtomicDataProperty):
    &quot;&quot;&quot;
    Attributes
    ----------
    zeta_data : pandas.DataFrame, dtype float
        Zeta data for the elements used. Indexed by atomic number, ion number.
        Columns are temperature values up to 40,000 K in iterations of 2,000 K.
        The zeta value represents the fraction of recombination events
        from the ionized state that go directly to the ground state.
    &quot;&quot;&quot;

    outputs = (&quot;zeta_data&quot;,)

    def _filter_atomic_property(self, zeta_data, selected_atoms):
        zeta_data[&quot;atomic_number&quot;] = zeta_data.index.codes[0] + 1
        zeta_data[&quot;ion_number&quot;] = zeta_data.index.codes[1] + 1
        zeta_data = zeta_data[zeta_data.atomic_number.isin(selected_atoms)]
        zeta_data_check = counter(zeta_data.atomic_number.values)
        keys = np.array(list(zeta_data_check.keys()))
        values = np.array(zeta_data_check.values())
        if np.all(keys + 1 == values) and keys:
            return zeta_data
        else:
            #            raise IncompleteAtomicData(&#39;zeta data&#39;)
            # This currently replaces missing zeta data with 1, which is necessary with
            # the present atomic data. Will replace with the error above when I have
            # complete atomic data.
            missing_ions = []
            updated_index = []
            for atom in selected_atoms:
                for ion in range(1, atom + 2):
                    if (atom, ion) not in zeta_data.index:
                        missing_ions.append((atom, ion))
                    updated_index.append([atom, ion])
            logger.warning(
                f&quot;Zeta_data missing - replaced with 1s. Missing ions: {missing_ions}&quot;
            )
            updated_index = np.array(updated_index)
            updated_dataframe = pd.DataFrame(
                index=pd.MultiIndex.from_arrays(
                    updated_index.transpose().astype(int)
                ),
                columns=zeta_data.columns,
            )
            for value in range(len(zeta_data)):
                updated_dataframe.loc[
                    zeta_data.atomic_number.values[value],
                    zeta_data.ion_number.values[value],
                ] = zeta_data.loc[
                    zeta_data.atomic_number.values[value],
                    zeta_data.ion_number.values[value],
                ]
            updated_dataframe = updated_dataframe.astype(float)
            updated_index = pd.DataFrame(updated_index)
            updated_dataframe[&quot;atomic_number&quot;] = np.array(updated_index[0])
            updated_dataframe[&quot;ion_number&quot;] = np.array(updated_index[1])
            updated_dataframe = updated_dataframe.fillna(1.0)
            return updated_dataframe

    def _set_index(self, zeta_data):
        return zeta_data.set_index([&quot;atomic_number&quot;, &quot;ion_number&quot;])</div>



<div class="viewcode-block" id="NLTEData">
<a class="viewcode-back" href="../../../../api/tardis.plasma.properties.atomic.html#tardis.plasma.properties.atomic.NLTEData">[docs]</a>
class NLTEData(ProcessingPlasmaProperty):
    &quot;&quot;&quot;
    Attributes
    ----------
    nlte_data :
        #Finish later (need atomic dataset with NLTE data).
    &quot;&quot;&quot;

    outputs = (&quot;nlte_data&quot;,)

<div class="viewcode-block" id="NLTEData.calculate">
<a class="viewcode-back" href="../../../../api/tardis.plasma.properties.atomic.html#tardis.plasma.properties.atomic.NLTEData.calculate">[docs]</a>
    def calculate(self, atomic_data):
        if getattr(self, self.outputs[0]) is not None:
            return (getattr(self, self.outputs[0]),)
        else:
            return atomic_data.nlte_data</div>
</div>



<div class="viewcode-block" id="YgData">
<a class="viewcode-back" href="../../../../api/tardis.plasma.properties.atomic.html#tardis.plasma.properties.atomic.YgData">[docs]</a>
class YgData(ProcessingPlasmaProperty):
    &quot;&quot;&quot;
    Attributes
    ----------
    yg_data : pandas.DataFrame
        Table of thermally averaged effective collision strengths
        (divided by the statistical weight of the lower level) Y_ij / g_i .
        Columns are temperatures.
    t_yg : numpy.ndarray
        Temperatures at which collision strengths are tabulated.
    yg_index : Pandas MultiIndex
    delta_E_yg : pandas.DataFrame
        Energy difference between upper and lower levels coupled by collisions.
    yg_idx : pandas.DataFrame
        Source_level_idx and destination_level_idx of collision transitions.
        Indexed by atomic_number, ion_number, level_number_lower,
        level_number_upper.
    &quot;&quot;&quot;

    outputs = (&quot;yg_data&quot;, &quot;t_yg&quot;, &quot;yg_index&quot;, &quot;delta_E_yg&quot;, &quot;yg_idx&quot;)
    latex_name = (
        r&quot;\frac{Y_{ij}}{g_i}&quot;,
        r&quot;T_\textrm{Yg}&quot;,
        r&quot;\textrm{yg_index}&quot;,
        r&quot;\delta E_{ij}&quot;,
        r&quot;\textrm{yg_idx}&quot;,
    )

<div class="viewcode-block" id="YgData.calculate">
<a class="viewcode-back" href="../../../../api/tardis.plasma.properties.atomic.html#tardis.plasma.properties.atomic.YgData.calculate">[docs]</a>
    def calculate(self, atomic_data, continuum_interaction_species):
        yg_data = atomic_data.yg_data
        if yg_data is None:
            raise ValueError(
                &quot;Tardis does not support continuum interactions for atomic data sources that do not contain yg_data&quot;
            )

        mask_selected_species = yg_data.index.droplevel(
            [&quot;level_number_lower&quot;, &quot;level_number_upper&quot;]
        ).isin(continuum_interaction_species)
        yg_data = yg_data[mask_selected_species]

        t_yg = atomic_data.collision_data_temperatures
        yg_data.columns = t_yg
        approximate_yg_data = self.calculate_yg_van_regemorter(
            atomic_data, t_yg, continuum_interaction_species
        )

        yg_data = yg_data.combine_first(approximate_yg_data)

        energies = atomic_data.levels.energy
        index = yg_data.index
        lu_index = index.droplevel(&quot;level_number_lower&quot;)
        ll_index = index.droplevel(&quot;level_number_upper&quot;)
        delta_E = energies.loc[lu_index].values - energies.loc[ll_index].values
        delta_E = pd.Series(delta_E, index=index)

        source_idx = atomic_data.macro_atom_references.loc[
            ll_index
        ].references_idx
        destination_idx = atomic_data.macro_atom_references.loc[
            lu_index
        ].references_idx
        yg_idx = pd.DataFrame(
            {
                &quot;source_level_idx&quot;: source_idx.values,
                &quot;destination_level_idx&quot;: destination_idx.values,
            },
            index=index,
        )
        return yg_data, t_yg, index, delta_E, yg_idx</div>


<div class="viewcode-block" id="YgData.calculate_yg_van_regemorter">
<a class="viewcode-back" href="../../../../api/tardis.plasma.properties.atomic.html#tardis.plasma.properties.atomic.YgData.calculate_yg_van_regemorter">[docs]</a>
    @classmethod
    def calculate_yg_van_regemorter(
        cls, atomic_data, t_electrons, continuum_interaction_species
    ):
        &quot;&quot;&quot;
        Calculate collision strengths in the van Regemorter approximation.

        This function calculates thermally averaged effective collision
        strengths (divided by the statistical weight of the lower level)
        Y_ij / g_i using the van Regemorter approximation.

        Parameters
        ----------
        atomic_data : tardis.io.atom_data.AtomData
        t_electrons : numpy.ndarray
        continuum_interaction_species : pandas.MultiIndex

        Returns
        -------
        pandas.DataFrame
            Thermally averaged effective collision strengths
            (divided by the statistical weight of the lower level) Y_ij / g_i

        Notes
        -----
        See Eq. 9.58 in [2].

        References
        ----------
        .. [1] van Regemorter, H., “Rate of Collisional Excitation in Stellar
               Atmospheres.”, The Astrophysical Journal, vol. 136, p. 906, 1962.
               doi:10.1086/147445.
        .. [2] Hubeny, I. and Mihalas, D., &quot;Theory of Stellar Atmospheres&quot;. 2014.
        &quot;&quot;&quot;
        I_H = atomic_data.ionization_data.loc[(1, 1)]

        mask_selected_species = atomic_data.lines.index.droplevel(
            [&quot;level_number_lower&quot;, &quot;level_number_upper&quot;]
        ).isin(continuum_interaction_species)
        lines_filtered = atomic_data.lines[mask_selected_species]
        f_lu = lines_filtered.f_lu.values
        nu_lines = lines_filtered.nu.values

        yg = f_lu * (I_H / (H * nu_lines)) ** 2
        coll_const = A0**2 * np.pi * np.sqrt(8 * K_B / (np.pi * M_E))
        yg = 14.5 * coll_const * t_electrons * yg[:, np.newaxis]

        u0 = nu_lines[np.newaxis].T / t_electrons * (H / K_B)
        gamma = 0.276 * cls.exp1_times_exp(u0)
        gamma[gamma &lt; 0.2] = 0.2
        yg *= u0 * gamma / BETA_COLL
        yg = pd.DataFrame(yg, index=lines_filtered.index, columns=t_electrons)

        return yg</div>


<div class="viewcode-block" id="YgData.exp1_times_exp">
<a class="viewcode-back" href="../../../../api/tardis.plasma.properties.atomic.html#tardis.plasma.properties.atomic.YgData.exp1_times_exp">[docs]</a>
    @staticmethod
    def exp1_times_exp(x):
        &quot;&quot;&quot;
        Product of the Exponential integral E1 and an exponential.

        This function calculates the product of the Exponential integral E1
        and an exponential in a way that also works for large values.

        Parameters
        ----------
        x : array_like
            Input values.

        Returns
        -------
        array_like
            Output array.
        &quot;&quot;&quot;
        x = np.asarray(x)
        mask = x &gt; 500
        f = exp1(x) * np.exp(x * (~mask))
        # Use Laurent series for large values to avoid infinite exponential
        f[mask] = (x**-1 - x**-2 + 2 * x**-3 - 6 * x**-4)[mask]
        return f</div>
</div>



<div class="viewcode-block" id="YgInterpolator">
<a class="viewcode-back" href="../../../../api/tardis.plasma.properties.atomic.html#tardis.plasma.properties.atomic.YgInterpolator">[docs]</a>
class YgInterpolator(ProcessingPlasmaProperty):
    &quot;&quot;&quot;
    Attributes
    ----------
    yg_interp : scipy.interpolate.PchipInterpolator
        Interpolates the thermally averaged effective collision strengths
        (divided by the statistical weight of the lower level) Y_ij / g_i as
        a function of electron temperature.
    &quot;&quot;&quot;

    outputs = (&quot;yg_interp&quot;,)
    latex_name = (&quot;\\frac{Y_ij}{g_i}_{\\textrm{interp}}&quot;,)

<div class="viewcode-block" id="YgInterpolator.calculate">
<a class="viewcode-back" href="../../../../api/tardis.plasma.properties.atomic.html#tardis.plasma.properties.atomic.YgInterpolator.calculate">[docs]</a>
    def calculate(self, yg_data, t_yg):
        yg_interp = PchipInterpolator(t_yg, yg_data, axis=1, extrapolate=True)
        return yg_interp</div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2013-2025, TARDIS Collaboration.
      <span class="lastupdated">Last updated on 12 Oct 2025.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>