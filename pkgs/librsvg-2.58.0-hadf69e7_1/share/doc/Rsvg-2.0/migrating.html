<!--
SPDX-FileCopyrightText: Librsvg developers

SPDX-License-Identifier: LGPL-2.1-or-later
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <title>Rsvg &ndash; 2.0: Migrating from old APIs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta charset="utf-8" />

  
  <meta property="og:type" content="website"/>

  
  <meta property="og:image:width" content="256"/>
  <meta property="og:image:height" content="256"/>
  <meta property="og:image:secure_url" content="librsvg-r.svg"/>
  <meta property="og:image:alt" content="Rsvg-2.0"/>
  

  
  <meta property="og:title" content="Rsvg: Migrating from old APIs"/>
  <meta property="og:description" content="Reference for Rsvg-2.0: Migrating from old APIs"/>
  <meta name="twitter:title" content="Rsvg: Migrating from old APIs"/>
  <meta name="twitter:description" content="Reference for Rsvg-2.0: Migrating from old APIs"/>


  
  <meta name="twitter:card" content="summary"/>

  
  
  
  

  <link rel="stylesheet" href="style.css" type="text/css" />

  

  
  <script src="urlmap.js"></script>
  
  
  <script src="fzy.js"></script>
  <script src="search.js"></script>
  
  <script src="main.js"></script>
</head>

<body>
  <div id="body-wrapper" tabindex="-1">

    <nav class="sidebar devhelp-hidden">
      
      <div class="section">
        <img src="librsvg-r.svg" class="logo"/>
      </div>
      
      
      <div class="search section">
        <form id="search-form" autocomplete="off">
          <input id="search-input" type="text" name="do-not-autocomplete" placeholder="Click, or press 's' to search" autocomplete="off"/>
        </form>
      </div>
      
      <div class="section namespace">
        <h3><a href="index.html">Rsvg</a></h3>
        <p>API Version: 2.0</p>
        
        <p>Library Version: 2.58.0</p>
        
      </div>
      
      
      <div class="section generator">
        <p>Generated by <a href="https://gitlab.gnome.org/GNOME/gi-docgen">gi-docgen</a> 2023.3</p>
      </div>
    </nav>

    <button id="btn-to-top" class="hidden"><span class="up-arrow"></span></button>

    
<section id="main" class="content">
  
  <h4 id="title" style="display:flex;">
    Migrating from old APIs
    <a href="#title" class="anchor"></a>
    
  </h4>
  
  <section>
    <div class="docblock">
    <h1 id="migrating-from-old-apis">Migrating from old APIs<a class="md-anchor" href="#migrating-from-old-apis" title="Permanent link"></a></h1>
<h2 id="migrating-from-the-deprecated-api-that-does-not-use-viewports">Migrating from the deprecated API that does not use viewports<a class="md-anchor" href="#migrating-from-the-deprecated-api-that-does-not-use-viewports" title="Permanent link"></a></h2>
<p>First, some context. Until librsvg version 2.44, the only way to
render an <a href="class.Handle.html"><code>RsvgHandle</code></a> into a Cairo context was with the
functions <a href="method.Handle.render_cairo.html"><code>rsvg_handle_render_cairo(handle,
cairo_t)</code></a> and
<a href="method.Handle.render_cairo_sub.html"><code>rsvg_handle_render_cairo_sub(handle, cairo_t,
id)</code></a> — respectively, to
render the whole document, and to render a single &#34;layer&#34; from it.
Both functions assumed that the <span class="caps">SVG</span> document was to be rendered at its
&#34;natural size&#34;, or to the size overriden with
<a href="method.Handle.set_size_callback.html"><code>rsvg_handle_set_size_callback()</code></a>. Since the Cairo context can already
have an affine transform applied to it, that transform can further
change the size of the rendered&nbsp;image.</p>
<p>Librsvg 2.46 introduced the following functions, designed to replace the
<code>render_cairo</code> ones:</p>
<ul>
<li><a href="method.Handle.render_document.html"><code>rsvg_handle_render_document()</code></a> - renders the whole&nbsp;document</li>
<li><a href="method.Handle.render_layer.html"><code>rsvg_handle_render_layer()</code></a> - renders a single&nbsp;layer</li>
<li><a href="method.Handle.render_element.html"><code>rsvg_handle_render_element()</code></a> - renders a single&nbsp;element</li>
<li>Plus corresponding functions to get the geometries of the&nbsp;document/layer/element.</li>
</ul>
<p>All of those functions take a viewport argument. Let&#39;s see what this
means. But first, some&nbsp;history.</p>
<h3 id="historical-note-before-librsvg-supported-viewports">Historical note: before librsvg supported viewports<a class="md-anchor" href="#historical-note-before-librsvg-supported-viewports" title="Permanent link"></a></h3>
<p>When librsvg was first written, its <span class="caps">API</span> basically consisted of only
functions to load an <a href="class.Handle.html"><code>RsvgHandle</code></a>, plus <a href="method.Handle.get_pixbuf.html"><code>rsvg_handle_get_pixbuf()</code></a> to
render it directly to a GdkPixbuf image. Internally the library used
libart (a pre-Cairo 2D rendering library), but did not expose it in the
public <span class="caps">API</span>.</p>
<p>The only way to specify a size at which to render an <a href="class.Handle.html"><code>RsvgHandle</code></a> was with
<a href="method.Handle.set_size_callback.html"><code>rsvg_handle_set_size_callback()</code></a>, and the callback would run at an
unspecified time during <em>loading</em>: when just enough of the <span class="caps">SVG</span> document
had been loaded to read in the <code>width/height</code> attributes of the toplevel
<code>&lt;svg&gt;</code> element, the callback would let the application override these
values with its own desired&nbsp;size.</p>
<p>Some years later, Cairo was introduced, and it started to replace
libart. Unlike libart, which could only render to in-memory <span class="caps">RGBA</span>
buffers, Cairo had a notion of &#34;backends&#34;: it could render to <span class="caps">RGBA</span>
buffers, or it could translate its drawing model commands into <span class="caps">PDF</span> or
PostScript. In Cairo&#39;s terms, one creates a <a href="https://www.cairographics.org/manual/cairo-cairo-surface-t.html"><code>cairo_surface_t</code></a> of a
particular kind (in-memory image surface, <span class="caps">PDF</span> surface, <span class="caps">EPS</span> surface,
etc.), and then a <a href="https://www.cairographics.org/manual/cairo-cairo-t.html"><code>cairo_t</code></a> context for the surface. The context is what
makes the drawing commands&nbsp;available.</p>
<p>Being able to render <span class="caps">SVG</span> documents directly to <span class="caps">PDF</span> or PostScript was
clearly attractive, so librsvg&#39;s <span class="caps">API</span> of <a href="method.Handle.get_pixbuf.html"><code>rsvg_handle_get_pixbuf()</code></a>
would clearly not be enough. It would be better to pass a <a href="https://www.cairographics.org/manual/cairo-cairo-t.html"><code>cairo_t</code></a> for
an already-created surface, and have librsvg issue its drawing commands
to it. Then the application would be in control of the surface type, or
in the case of <span class="caps">GTK</span> widgets, they would already get a <a href="https://www.cairographics.org/manual/cairo-cairo-t.html"><code>cairo_t</code></a> passed to
their drawing functions. Librsvg got modified to export a
<a href="method.Handle.render_cairo.html"><code>rsvg_handle_render_cairo(handle, cairo_t)</code></a>, and then it reimplemented the old
<a href="method.Handle.get_pixbuf.html"><code>rsvg_handle_get_pixbuf()</code></a> in terms of&nbsp;Cairo.</p>
<p>At this point, librsvg still kept the notion of rendering <span class="caps">SVG</span> documents
at their &#34;natural size&#34;: the <code>&lt;svg&gt;</code> element&#39;s <code>width</code> and <code>height</code>
attributes converted to pixels (e.g. converting from <code>width="5cm"</code> by
using the dots-per-inch value from the <a href="class.Handle.html"><code>RsvgHandle</code></a>), or if those
attributes don&#39;t exist, by using the <code>viewBox</code> as a pixel size. The
assumption was that if you needed a different size, you could always
start by setting the transformation matrix on your <a href="https://www.cairographics.org/manual/cairo-cairo-t.html"><code>cairo_t</code></a> and then
rendering to&nbsp;that.</p>
<h3 id="the-problem-with-not-having-viewports">The problem with not having viewports<a class="md-anchor" href="#the-problem-with-not-having-viewports" title="Permanent link"></a></h3>
<p>Most applications which use librsvg to render <span class="caps">SVG</span> assets for their user
interface generally work in the same way. For example, to take an <span class="caps">SVG</span>
icon and render it, they do something like&nbsp;this:</p>
<ol>
<li>
<p>Create an <a href="class.Handle.html"><code>RsvgHandle</code></a> by loading it from the <span class="caps">SVG</span> icon&nbsp;data.</p>
</li>
<li>
<p>Ask the <a href="class.Handle.html"><code>RsvgHandle</code></a> for its&nbsp;dimensions.</p>
</li>
<li>
<p>Divide the dimensions by the <span class="caps">GUI</span>&#39;s preferred size for&nbsp;icons.</p>
</li>
<li>
<p>Translate a Cairo context so the icon will appear at the desired
    location.  Scale the Cairo context by the result of the previous
    step to obtain the desired&nbsp;dimensions.</p>
</li>
<li>
<p>Render the <a href="class.Handle.html"><code>RsvgHandle</code></a> in that Cairo&nbsp;context.</p>
</li>
</ol>
<p>This is&#8230; too much work. The web world has moved on to using the <span class="caps">CSS</span>
box model practically everywhere. To embed an image you specify <em>where</em>
and at <em>what size</em> you want to place it, and it gets done automatically.
You actually have to do extra work if you want to do non-standard things
like scale an image&nbsp;non-proportionally.</p>
<h3 id="the-new-rendering-api-that-uses-viewports">The new rendering API that uses viewports<a class="md-anchor" href="#the-new-rendering-api-that-uses-viewports" title="Permanent link"></a></h3>
<p>Starting with librsvg 2.46, the following functions are&nbsp;available:</p>
<div class="codehilite"><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">width</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">RsvgRectangle</span><span class="p">;</span>

<span class="n">gboolean</span><span class="w"> </span><span class="nf">rsvg_handle_render_document</span><span class="w"> </span><span class="p">(</span><span class="n">RsvgHandle</span><span class="w">           </span><span class="o">*</span><span class="n">handle</span><span class="p">,</span>
<span class="w">                                      </span><span class="n">cairo_t</span><span class="w">              </span><span class="o">*</span><span class="n">cr</span><span class="p">,</span>
<span class="w">                                      </span><span class="k">const</span><span class="w"> </span><span class="n">RsvgRectangle</span><span class="w">  </span><span class="o">*</span><span class="n">viewport</span><span class="p">,</span>
<span class="w">                                      </span><span class="n">GError</span><span class="w">              </span><span class="o">**</span><span class="n">error</span><span class="p">);</span>

<span class="n">gboolean</span><span class="w"> </span><span class="nf">rsvg_handle_render_layer</span><span class="w">    </span><span class="p">(</span><span class="n">RsvgHandle</span><span class="w">           </span><span class="o">*</span><span class="n">handle</span><span class="p">,</span>
<span class="w">                                      </span><span class="n">cairo_t</span><span class="w">              </span><span class="o">*</span><span class="n">cr</span><span class="p">,</span>
<span class="w">                                      </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w">           </span><span class="o">*</span><span class="n">id</span><span class="p">,</span>
<span class="w">                                      </span><span class="k">const</span><span class="w"> </span><span class="n">RsvgRectangle</span><span class="w">  </span><span class="o">*</span><span class="n">viewport</span><span class="p">,</span>
<span class="w">                                      </span><span class="n">GError</span><span class="w">              </span><span class="o">**</span><span class="n">error</span><span class="p">);</span>

<span class="n">gboolean</span><span class="w"> </span><span class="nf">rsvg_handle_render_element</span><span class="w">  </span><span class="p">(</span><span class="n">RsvgHandle</span><span class="w">           </span><span class="o">*</span><span class="n">handle</span><span class="p">,</span>
<span class="w">                                      </span><span class="n">cairo_t</span><span class="w">              </span><span class="o">*</span><span class="n">cr</span><span class="p">,</span>
<span class="w">                                      </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w">           </span><span class="o">*</span><span class="n">id</span><span class="p">,</span>
<span class="w">                                      </span><span class="k">const</span><span class="w"> </span><span class="n">RsvgRectangle</span><span class="w">  </span><span class="o">*</span><span class="n">element_viewport</span><span class="p">,</span>
<span class="w">                                      </span><span class="n">GError</span><span class="w">              </span><span class="o">**</span><span class="n">error</span><span class="p">);</span>
</code></pre></div>

<p>For brevity we will omit the <code>rsvg_handle</code> namespace prefix, and just talk about the actual
function names. You can see that <a href="method.Handle.render_document.html"><code>render_document</code></a>
is basically the same as <a href="method.Handle.render_cairo.html"><code>render_cairo</code></a>, but it has an
extra <code>viewport</code> argument. The same occurs in
<a href="method.Handle.render_layer.html"><code>render_layer</code></a> versus
<a href="method.Handle.render_cairo_sub.html"><code>render_cairo_sub</code></a>.</p>
<p>In both of those cases — <a href="method.Handle.render_document.html"><code>render_document</code></a> and
<a href="method.Handle.render_layer.html"><code>render_layer</code></a> —, the <code>viewport</code> argument specifies a
rectangle into which the <span class="caps">SVG</span> will be positioned and scaled to fit. Consider something like&nbsp;this:</p>
<div class="codehilite"><pre><span></span><code><span class="n">RsvgRectangle</span><span class="w"> </span><span class="n">viewport</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">10.0</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">20.0</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">640.0</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">480.0</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">rsvg_handle_render_document</span><span class="w"> </span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="n">cr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">viewport</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
</code></pre></div>

<p>This is equivalent to first figuring out the scaling factor to make the <span class="caps">SVG</span> fit
proportionally in 640×480 pixels, then translating the <code>cr</code> by (10, 20) pixels, and then
calling <a href="method.Handle.render_cairo.html"><code>rsvg_handle_render_cairo()</code></a>. If the <span class="caps">SVG</span> has different proportions than the
width and height of the rectangle, it will be rendered and centered to fit the&nbsp;rectangle.</p>
<hr />
<p><strong>Note:</strong> <a href="method.Handle.render_element.html"><code>rsvg_handle_render_element()</code></a> is new in librsvg 2.46. It extracts a
single element from the <span class="caps">SVG</span> and renders it scaled to the viewport you
specify. It is different from <code>render_layer</code> (or the old-style
<code>render_cairo_sub</code>) in that those ones act as if they rendered the whole
document&#39;s area, but they only paint the layer you&nbsp;specify.</p>
<hr />
<p>Even better: the old functions to get an <span class="caps">SVG</span>&#39;s natural dimensions, like
<a href="method.Handle.get_dimensions.html"><code>rsvg_handle_get_dimensions()</code></a>, returned integers instead of
floating-point numbers, so you could not always get an exact fit. Please
use the new <code>get_geometry</code> functions that take viewports; they will give you easier and
better&nbsp;results:</p>
<ul>
<li><a href="method.Handle.get_geometry_for_layer.html"><code>rsvg_handle_get_geometry_for_layer()</code></a></li>
<li><a href="method.Handle.get_geometry_for_element.html"><code>rsvg_handle_get_geometry_for_element()</code></a></li>
</ul>
<h3 id="new-api-for-obtaining-an-svgs-dimensions">New API for obtaining an SVG's dimensions<a class="md-anchor" href="#new-api-for-obtaining-an-svgs-dimensions" title="Permanent link"></a></h3>
<p>Per the previous section, you should seldom need to obtain the &#34;natural
size&#34; of an <span class="caps">SVG</span> document now that you can render it directly into a
viewport. But if you still need to know what the <span class="caps">SVG</span> document specifies
for its own size, you can use the following functions, depending on the
level of detail you&nbsp;require:</p>
<div class="codehilite"><pre><span></span><code><span class="n">gboolean</span><span class="w"> </span><span class="nf">rsvg_handle_get_intrinsic_size_in_pixels</span><span class="w"> </span><span class="p">(</span><span class="n">RsvgHandle</span><span class="w"> </span><span class="o">*</span><span class="n">handle</span><span class="p">,</span>
<span class="w">                                                   </span><span class="n">gdouble</span><span class="w">    </span><span class="o">*</span><span class="n">out_width</span><span class="p">,</span>
<span class="w">                                                   </span><span class="n">gdouble</span><span class="w">    </span><span class="o">*</span><span class="n">out_height</span><span class="p">);</span>
</code></pre></div>

<p><a href="method.Handle.get_intrinsic_size_in_pixels.html"><code>rsvg_handle_get_intrinsic_size_in_pixels()</code></a> returns an exact width and height in
floating-point pixels. <strong>You should round up to the next integer</strong> if you need to allocate
a pixel buffer big enough, to avoid clipping the last column or row of pixels, which may
be only partially covered.  For example, if a document&#8217;s width is <code>41.3</code> <span class="caps">CSS</span> pixels, you
should create a raster image <code>42</code> pixels wide so it fits without clipping the last pixel.
You can do this with the <code>ceil()</code> function.</p>
<p><a href="method.Handle.get_intrinsic_size_in_pixels.html"><code>rsvg_handle_get_intrinsic_size_in_pixels()</code></a> works by resolving the
<code>width/height</code> attributes of the toplevel <code>&lt;svg&gt;</code> element against the
handle&#39;s current <span class="caps">DPI</span> and the <code>font-size</code> that is defined for the
<code>&lt;svg&gt;</code> element.</p>
<p>However, that is only possible if the <code>width/height</code> attributes actually
exist and are in physical units. The function will return <span class="caps">FALSE</span> if the
<span class="caps">SVG</span> has no resolvable units, for example if the <code>width/height</code>
attributes are specified in percentages (e.g. <code>width="50%"</code>), since the
function has no knowledge of the viewport where you will place the <span class="caps">SVG</span>,
or if those attributes are not&nbsp;specified.</p>
<p>The other way of obtaining an <span class="caps">SVG</span>&#39;s dimensions is to actually query its
&#34;intrinsic dimensions&#34;, i.e. what is actually specified in the <span class="caps">SVG</span>&nbsp;document:</p>
<div class="codehilite"><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">RSVG_UNIT_PERCENT</span><span class="p">,</span>
<span class="w">    </span><span class="n">RSVG_UNIT_PX</span><span class="p">,</span>
<span class="w">    </span><span class="n">RSVG_UNIT_EM</span><span class="p">,</span>
<span class="w">    </span><span class="n">RSVG_UNIT_EX</span><span class="p">,</span>
<span class="w">    </span><span class="n">RSVG_UNIT_IN</span><span class="p">,</span>
<span class="w">    </span><span class="n">RSVG_UNIT_CM</span><span class="p">,</span>
<span class="w">    </span><span class="n">RSVG_UNIT_MM</span><span class="p">,</span>
<span class="w">    </span><span class="n">RSVG_UNIT_PT</span><span class="p">,</span>
<span class="w">    </span><span class="n">RSVG_UNIT_PC</span>
<span class="p">}</span><span class="w"> </span><span class="n">RsvgUnit</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">double</span><span class="w">   </span><span class="n">length</span><span class="p">;</span>
<span class="w">    </span><span class="n">RsvgUnit</span><span class="w"> </span><span class="n">unit</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">RsvgLength</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">rsvg_handle_get_intrinsic_dimensions</span><span class="w"> </span><span class="p">(</span><span class="n">RsvgHandle</span><span class="w"> </span><span class="o">*</span><span class="n">handle</span><span class="p">,</span>
<span class="w">                                           </span><span class="n">gboolean</span><span class="w">   </span><span class="o">*</span><span class="n">out_has_width</span><span class="p">,</span>
<span class="w">                                           </span><span class="n">RsvgLength</span><span class="w"> </span><span class="o">*</span><span class="n">out_width</span><span class="p">,</span>
<span class="w">                                           </span><span class="n">gboolean</span><span class="w">   </span><span class="o">*</span><span class="n">out_has_height</span><span class="p">,</span>
<span class="w">                                           </span><span class="n">RsvgLength</span><span class="w"> </span><span class="o">*</span><span class="n">out_height</span><span class="p">,</span>
<span class="w">                                           </span><span class="n">gboolean</span><span class="w">   </span><span class="o">*</span><span class="n">out_has_viewbox</span><span class="p">,</span>
<span class="w">                                           </span><span class="n">RsvgRectangle</span><span class="w"> </span><span class="o">*</span><span class="n">out_viewbox</span><span class="p">);</span>
</code></pre></div>

<p><a href="method.Handle.get_intrinsic_dimensions.html"><code>rsvg_handle_get_intrinsic_dimensions()</code></a> will tell you precisely if the toplevel
<code>&lt;svg&gt;</code> has <code>width/height</code> attributes and their values, and also whether it has a
<code>viewBox</code> and its&nbsp;value.</p>
<hr />
<p><strong>Note:</strong> Remember that SVGs are <em>scalable</em>. They are not like raster images which have an
exact size in pixels, and which you must always take into account to scale them to a
convenient size. For SVGs, you can just render them to a viewport, and avoid working
directly with their size — which is kind of arbitrary, and all that matters is the
document&#8217;s aspect&nbsp;ratio.</p>
<hr />
<h3 id="svgs-with-no-intrinsic-dimensions-nor-aspect-ratio">SVGs with no intrinsic dimensions nor aspect ratio<a class="md-anchor" href="#svgs-with-no-intrinsic-dimensions-nor-aspect-ratio" title="Permanent link"></a></h3>
<p><span class="caps">SVG</span> documents that have none of the <code>width</code>, <code>height</code>, or <code>viewBox</code> attributes are
thankfully not very common, but they are hard to deal with: the software cannot
immediately know their natural size or aspect ratio, so they cannot be easily scaled to
fit within a viewport.  If you need to measure the extents of all the objects in an <span class="caps">SVG</span>
document, you can use <a href="method.Handle.get_geometry_for_element.html"><code>rsvg_handle_get_geometry_for_element()</code></a> by passing <code>NULL</code> for
the target element&#8217;s <code>id</code>; this will measure all the elements in the&nbsp;document.</p>
<h2 id="migrating-to-the-geometry-apis">Migrating to the geometry APIs<a class="md-anchor" href="#migrating-to-the-geometry-apis" title="Permanent link"></a></h2>
<p>Until librsvg 2.44, the available APIs to query the geometry of a layer
or element were&nbsp;these:</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">_RsvgPositionData</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">gboolean</span><span class="w"> </span><span class="nf">rsvg_handle_get_position_sub</span><span class="w"> </span><span class="p">(</span><span class="n">RsvgHandle</span><span class="w">       </span><span class="o">*</span><span class="n">handle</span><span class="p">,</span>
<span class="w">                                       </span><span class="n">RsvgPositionData</span><span class="w"> </span><span class="o">*</span><span class="n">position_data</span><span class="p">,</span>
<span class="w">                                       </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w">       </span><span class="o">*</span><span class="n">id</span><span class="p">);</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">_RsvgDimensionData</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">height</span><span class="p">;</span>
<span class="w">    </span><span class="n">gdouble</span><span class="w"> </span><span class="n">em</span><span class="p">;</span>
<span class="w">    </span><span class="n">gdouble</span><span class="w"> </span><span class="n">ex</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">gboolean</span><span class="w"> </span><span class="nf">rsvg_handle_get_dimensions_sub</span><span class="w"> </span><span class="p">(</span><span class="n">RsvgHandle</span><span class="w">        </span><span class="o">*</span><span class="n">handle</span><span class="p">,</span>
<span class="w">                                         </span><span class="n">RsvgDimensionData</span><span class="w"> </span><span class="o">*</span><span class="n">dimension_data</span><span class="p">,</span>
<span class="w">                                         </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w">        </span><span class="o">*</span><span class="n">id</span><span class="p">);</span>
</code></pre></div>

<p>These functions are inconvenient — separate calls to get the position
and dimensions —, and also inexact, since they only return integer
values, while <span class="caps">SVG</span> uses floating-point&nbsp;units.</p>
<p>Since librsvg 2.46, you can use these functions&nbsp;instead:</p>
<div class="codehilite"><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">width</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">RsvgRectangle</span><span class="p">;</span>

<span class="n">gboolean</span><span class="w"> </span><span class="nf">rsvg_handle_get_geometry_for_layer</span><span class="w"> </span><span class="p">(</span><span class="n">RsvgHandle</span><span class="w">           </span><span class="o">*</span><span class="n">handle</span><span class="p">,</span>
<span class="w">                                             </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w">           </span><span class="o">*</span><span class="n">id</span><span class="p">,</span>
<span class="w">                                             </span><span class="k">const</span><span class="w"> </span><span class="n">RsvgRectangle</span><span class="w">  </span><span class="o">*</span><span class="n">viewport</span><span class="p">,</span>
<span class="w">                                             </span><span class="n">RsvgRectangle</span><span class="w">        </span><span class="o">*</span><span class="n">out_ink_rect</span><span class="p">,</span>
<span class="w">                                             </span><span class="n">RsvgRectangle</span><span class="w">        </span><span class="o">*</span><span class="n">out_logical_rect</span><span class="p">,</span>
<span class="w">                                             </span><span class="n">GError</span><span class="w">              </span><span class="o">**</span><span class="n">error</span><span class="p">);</span>

<span class="n">gboolean</span><span class="w"> </span><span class="nf">rsvg_handle_get_geometry_for_element</span><span class="w"> </span><span class="p">(</span><span class="n">RsvgHandle</span><span class="w">     </span><span class="o">*</span><span class="n">handle</span><span class="p">,</span>
<span class="w">                                               </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w">     </span><span class="o">*</span><span class="n">id</span><span class="p">,</span>
<span class="w">                                               </span><span class="n">RsvgRectangle</span><span class="w">  </span><span class="o">*</span><span class="n">out_ink_rect</span><span class="p">,</span>
<span class="w">                                               </span><span class="n">RsvgRectangle</span><span class="w">  </span><span class="o">*</span><span class="n">out_logical_rect</span><span class="p">,</span>
<span class="w">                                               </span><span class="n">GError</span><span class="w">        </span><span class="o">**</span><span class="n">error</span><span class="p">);</span>
</code></pre></div>

<p>These functions return exact floating-point values. They also give you
the ink rectangle, or area covered by paint, as well as the logical
rectangle, which is the extents of unstroked paths (i.e. just the&nbsp;outlines).</p>
<ul>
<li><a href="method.Handle.get_geometry_for_layer.html"><code>rsvg_handle_get_geometry_for_layer()</code></a></li>
<li><a href="method.Handle.get_geometry_for_element.html"><code>rsvg_handle_get_geometry_for_element()</code></a></li>
</ul>
    </div>
  </section>
</section>


    
<div id="toc" class="toc">
  <nav aria-labelledby="toc-title">
    <p id="toc-title">Content</p>
    <ul class="toc-list">
      
        
        <li class="toc-list-item"><a href="#migrating-from-the-deprecated-api-that-does-not-use-viewports"><span class="link-text">Migrating from the deprecated API that does not use viewports</span></a></li>
        
        <li class="toc-list-item"><a href="#migrating-to-the-geometry-apis"><span class="link-text">Migrating to the geometry APIs</span></a></li>
        
      
    </ul>
  </nav>
</div>


    <section id="search" class="content hidden"></section>

    <footer>
    
    </footer>
  </div>
</body>
</html>